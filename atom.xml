<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liushuaikobe</title>
  <subtitle>随便吐个槽而已</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.liushuaiko.be/"/>
  <updated>2016-12-11T15:02:34.000Z</updated>
  <id>http://blog.liushuaiko.be/</id>
  
  <author>
    <name>liushuaikobe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac上给树莓派安装Raspbian</title>
    <link href="http://blog.liushuaiko.be/blog/2016/12/11/pi-raspbian/"/>
    <id>http://blog.liushuaiko.be/blog/2016/12/11/pi-raspbian/</id>
    <published>2016-12-11T14:55:18.000Z</published>
    <updated>2016-12-11T15:02:34.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;下载img文件&quot;&gt;&lt;a href=&quot;#下载img文件&quot; class=&quot;headerlink&quot; title=&quot;下载img文件&quot;&gt;&lt;/a&gt;下载img文件&lt;/h2&gt;&lt;p&gt;到[这里]下载img文件，记得下载完成后比对一下文件的摘要，确保拿到的文件没有损坏：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ shasum ~/Downloads/2016-09-23-raspbian-jessie-lite.zip&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解压zip文件，得到img文件。&lt;/p&gt;
&lt;h2 id=&quot;格式化SD-Card&quot;&gt;&lt;a href=&quot;#格式化SD-Card&quot; class=&quot;headerlink&quot; title=&quot;格式化SD Card&quot;&gt;&lt;/a&gt;格式化SD Card&lt;/h2&gt;&lt;p&gt;要求SD Card必须是FAT，使用前先用Disk Utility格式化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/raspbian-1.png&quot; alt=&quot;raspbian-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意别选成你Mac的硬盘，不然可就酸爽了。&lt;/p&gt;
&lt;h2 id=&quot;unmount-SD-Card&quot;&gt;&lt;a href=&quot;#unmount-SD-Card&quot; class=&quot;headerlink&quot; title=&quot;unmount SD Card&quot;&gt;&lt;/a&gt;unmount SD Card&lt;/h2&gt;&lt;p&gt;打开终端，使用&lt;code&gt;diskutil&lt;/code&gt;找到你的SD Card并取消挂载，本例中，SD Card是&lt;code&gt;/dev/disk2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/raspbian-2.png&quot; alt=&quot;raspbian-2&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;烧入img&quot;&gt;&lt;a href=&quot;#烧入img&quot; class=&quot;headerlink&quot; title=&quot;烧入img&quot;&gt;&lt;/a&gt;烧入img&lt;/h2&gt;&lt;p&gt;使用下面的命令写入镜像。注意&lt;code&gt;if&lt;/code&gt;参数的值是img文件的path，&lt;code&gt;of&lt;/code&gt;参数的值是上一步找到的SD Card的标识符，但是&lt;code&gt;disk2&lt;/code&gt;换成了&lt;code&gt;rdisk2&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ sudo dd bs=1m if=/path/to/2016-09-23-raspbian-jessie-lite.img of=/dev/rdisk2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;整个过程需要几分钟。完毕后，系统就安装完毕了，插入Raspberry，系统初始账户名字为&lt;code&gt;pi&lt;/code&gt;，密码为&lt;code&gt;raspberry&lt;/code&gt;，搞起！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载img文件&quot;&gt;&lt;a href=&quot;#下载img文件&quot; class=&quot;headerlink&quot; title=&quot;下载img文件&quot;&gt;&lt;/a&gt;下载img文件&lt;/h2&gt;&lt;p&gt;到[这里]下载img文件，记得下载完成后比对一下文件的摘要，确保拿到的文件没有损坏：&lt;/p&gt;
&lt;fi
    
    </summary>
    
      <category term="其它" scheme="http://blog.liushuaiko.be/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Raspberry" scheme="http://blog.liushuaiko.be/tags/Raspberry/"/>
    
  </entry>
  
  <entry>
    <title>NSNotification避坑指南</title>
    <link href="http://blog.liushuaiko.be/blog/2016/10/23/nsnotification-deadlock/"/>
    <id>http://blog.liushuaiko.be/blog/2016/10/23/nsnotification-deadlock/</id>
    <published>2016-10-23T08:53:39.000Z</published>
    <updated>2016-10-23T09:11:03.000Z</updated>
    
    <content type="html">&lt;p&gt;NSNotification避坑指南。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;通知的发送&quot;&gt;&lt;a href=&quot;#通知的发送&quot; class=&quot;headerlink&quot; title=&quot;通知的发送&quot;&gt;&lt;/a&gt;通知的发送&lt;/h2&gt;&lt;p&gt;直接看段代码。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; notificationName = &lt;span class=&quot;type&quot;&gt;NSNotification&lt;/span&gt;.&lt;span class=&quot;type&quot;&gt;Name&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;be.liushuaiko.test&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Register Observer: \(Thread.current)&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NotificationCenter&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;.addObserver(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, selector: #selector(notificationHandler), name: notificationName, object: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;DispatchQueue&lt;/span&gt;.global().asyncAfter(deadline: &lt;span class=&quot;type&quot;&gt;DispatchTime&lt;/span&gt;.now() + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Post Notification: \(Thread.current)&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;NotificationCenter&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;.post(name: notificationName, object: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Post Ended&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;notificationHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;Thread&lt;/span&gt;.sleep(forTimeInterval: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(#function + &lt;span class=&quot;string&quot;&gt;&quot;: \(Thread.current)&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在main线程执行&lt;code&gt;foo&lt;/code&gt;，输出为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Register Observer: &amp;lt;NSThread: 0x6080000717c0&amp;gt;&amp;#123;number = 1, name = main&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Post Notification: &amp;lt;NSThread: 0x61000007b8c0&amp;gt;&amp;#123;number = 3, name = (null)&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;notificationHandler(): &amp;lt;NSThread: 0x61000007b8c0&amp;gt;&amp;#123;number = 3, name = (null)&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Post Ended&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数伊始，在主线程注册了一个Observer，在收到notification时，执行&lt;code&gt;notificationHandler&lt;/code&gt;方法。1s后在一个异步线程post notification。观察输出，有几个点，各位工友在使用Notification时务必牢记。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送者在哪个线程&lt;strong&gt;发送&lt;/strong&gt;的notification，接受者注册的selector就在哪个线程被&lt;strong&gt;执行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;发notification是一个&lt;strong&gt;同步&lt;/strong&gt;的过程。发送的过程中，&lt;code&gt;NotificationCenter&lt;/code&gt;查询dispatch table，已注册的Observer的selector逐个被执行，当全部执行完毕时，通知才发送完毕。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;安全隐患&quot;&gt;&lt;a href=&quot;#安全隐患&quot; class=&quot;headerlink&quot; title=&quot;安全隐患&quot;&gt;&lt;/a&gt;安全隐患&lt;/h2&gt;&lt;p&gt;另一个添加Observer的方法允许接收者指定一个block和一个&lt;code&gt;OperationQueue&lt;/code&gt;，当收到通知的时候，block会被add到这个queue上执行。&lt;/p&gt;
&lt;p&gt;func addObserver(forName name: NSNotification.Name?,&lt;br&gt;          object obj: Any?,&lt;br&gt;           queue: OperationQueue?,&lt;br&gt;           using block: @escaping (Notification) -&amp;gt; Void) -&amp;gt; NSObjectProtocol&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;OperationQueue&lt;/code&gt;对使用者屏蔽了线程的概念，这个方法给我们带来了便利的同时，如果使用不当，也会产生严重且难于调试的问题——线程死锁。看下面的例子。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 注册一个anonymous的Observer，提供一个block&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 期待收到通知时，这个block被add到main operation queue执行&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NotificationCenter&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;.addObserver(forName: notificationName, object: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, queue: &lt;span class=&quot;type&quot;&gt;OperationQueue&lt;/span&gt;.main) &amp;#123; &lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This will never print: + \(Thread.current)&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在一个异步线程发送通知&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 用一个semaphore，起到join thread的作用，防止main thread过早退出&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; semaphore = &lt;span class=&quot;type&quot;&gt;DispatchSemaphore&lt;/span&gt;(value: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;DispatchQueue&lt;/span&gt;.global().async &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Post Notification: \(Thread.current)&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ERROR: 发送notification的线程卡死在这里&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 本线程等待每个observer处理完毕&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;NotificationCenter&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;.post(name: notificationName, object: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        semaphore.signal()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Post Ended&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    semaphore.wait() &lt;span class=&quot;comment&quot;&gt;// ERROR: main thread卡死在这里&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;This will never print, neither&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;开始在main thread注册了一个匿名的Observer，在收到通知时，给定的block会被add到main operation queue上执行。main queue一定是在main thread执行的。之后，在一个background thread异步发送通知。代码中使用了一个semaphore来防止main thread退出，本意是让main thread等待background thread执行完成后（通知发送完毕）才继续往下执行，否则就阻塞在&lt;code&gt;semaphore.wait()&lt;/code&gt;处。&lt;/p&gt;
&lt;p&gt;让我们分析一下执行过程。先看main thread，首先注册Observer，没问题，往下走；接着给某background thread一个block，让其异步执行，注意main thread不会等在这里，提交了block后立刻往下走，到&lt;code&gt;semaphore.wait()&lt;/code&gt;，由于semaphore的资源数为0，在semaphore收到signal（V操作）前，main thread都会卡在这里。&lt;/p&gt;
&lt;p&gt;那么background thread呢？Notification Center发送通知，查自己的dispatch table，准备在main thread上执行Observer注册的block，但是main thread却由于卡在&lt;code&gt;semaphore.wait()&lt;/code&gt;处无法执行该block，而background thread也就由于无法完成发送通知的过程而无法对semaphore发送signal，也卡死了。&lt;/p&gt;
&lt;p&gt;两个线程因为互相等待对方执行完毕而产生死锁。这一切，都是因为发送通知是一个同步的过程。&lt;/p&gt;
&lt;p&gt;实际执行&lt;code&gt;foo&lt;/code&gt;，会发现程序程序输出了“Post Notification”后，便毫无反应。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Post Notification: &amp;lt;NSThread: 0x61800006dc00&amp;gt;&amp;#123;number = 3, name = (null)&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查看此时的线程栈，发现跟我们分析的一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/NSNotification-deadlock.png&quot; alt=&quot;stack&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果我们把上面注册Observer时提供的operation queue改为一个自定义的queue，如直接初始化一个&lt;code&gt;OperationQueue()&lt;/code&gt;，那么我们发现一切回归正常，输出如下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Post Notification: &amp;lt;NSThread: 0x608000079280&amp;gt;&amp;#123;number = 3, name = (null)&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;This will never print: + &amp;lt;NSThread: 0x6080000791c0&amp;gt;&amp;#123;number = 4, name = (null)&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Post Ended&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;This will never print, neither&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面例子的代码过于刻意，在实际的生产实践中，没人会去阻塞主线程。但是，如&lt;a href=&quot;https://medium.com/@elfenlaid/the-good-the-bad-and-the-notification-275198fa2e86#.h1bnvclk7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;里说的，对dispatch once token的争夺也会引发类似的死锁。如有必要，请读一下。因此在使用的过程中，务必小心。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSNotification避坑指南。&lt;/p&gt;
    
    </summary>
    
      <category term="移动互联网开发" scheme="http://blog.liushuaiko.be/categories/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.liushuaiko.be/tags/iOS/"/>
    
      <category term="NSNotification" scheme="http://blog.liushuaiko.be/tags/NSNotification/"/>
    
  </entry>
  
  <entry>
    <title>几件提升工作效率的利器</title>
    <link href="http://blog.liushuaiko.be/blog/2016/08/18/alfred-vim-tmux/"/>
    <id>http://blog.liushuaiko.be/blog/2016/08/18/alfred-vim-tmux/</id>
    <published>2016-08-18T14:25:55.000Z</published>
    <updated>2016-08-18T14:31:49.000Z</updated>
    
    <content type="html">&lt;p&gt;最近用的几件利器，大大提高了我的工作效率。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Alfred的Clipboard和Snippets&quot;&gt;&lt;a href=&quot;#Alfred的Clipboard和Snippets&quot; class=&quot;headerlink&quot; title=&quot;Alfred的Clipboard和Snippets&quot;&gt;&lt;/a&gt;Alfred的Clipboard和Snippets&lt;/h2&gt;&lt;p&gt;Alfred应该从很早的版本就有这些功能了，而我居然上周才掌握。&lt;/p&gt;
&lt;p&gt;除了经常被提起的search和workflow外，Alfred还可以实现Text Expand的功能，称为『Snippet』。即事先定义好一些Snippet和对应的缩写，Alfred会全局Observe你的输入（需要给Alfred辅助功能控制电脑的权限），如果输入命中了某个缩写词，它会立刻把缩写词替换成对应的Snippet。如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/alfred_1.gif&quot; alt=&quot;alfred_1&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，也可以关闭Observe，采用通过Hotkey唤醒Alfred查找的方式，如下图。可在Alfred Preference -&amp;gt; Features -&amp;gt; Snippets里进行Hotkey等具体设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/alfred_2.gif&quot; alt=&quot;alfred_2&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了这个功能外，Alfred还可以保存系统剪贴板的记录。这个也很实用，我经常有这样的需求：在iTerm里面复制了一个单词，然后到AppCode里去Find，过了一段时间，又要去其它地方查找这个词，按下Cmd + v时，发现剪贴板已然被覆盖。有了Alfred，最近粘贴了什么，随时调出，一目了然。当然，也有一些危险，因为稍有不慎，曾经粘贴过的羞羞的东西都会被保存起来看到😬，好在可以配置忽略来自某些指定应用的复制内容。详细可以在Alfred Preference -&amp;gt; Features -&amp;gt; Clipboard里设置。&lt;/p&gt;
&lt;h2 id=&quot;AppCode的Vim-Plugin&quot;&gt;&lt;a href=&quot;#AppCode的Vim-Plugin&quot; class=&quot;headerlink&quot; title=&quot;AppCode的Vim Plugin&quot;&gt;&lt;/a&gt;AppCode的Vim Plugin&lt;/h2&gt;&lt;p&gt;这个是之前Vim操作不熟练时，被我装了卸，卸了又装的一个AppCode插件。不仅是AppCode，其它JetBrains家的IDE都可以安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/alfred_3.png&quot; alt=&quot;vim&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近把忘了的Vim命令重新捡了捡，又趁闲暇时学了些高级Vim操作技巧，强迫自己适应Vim Mode下的AppCode，发现其学习曲线跟双拼很类似，不熟练的时候，的确有点慢有点着急，这时千万别放弃，随着时间的积累，会越来越high。&lt;/p&gt;
&lt;p&gt;我不会忘记那个下午，同事们挪动、敲击着鼠标， 而我熟练地移动着光标，再配合AppCode的无敌代码编辑，完成某方法最后一行代码，右手小指敲下回车，形成的那道完美的弧线。&lt;/p&gt;
&lt;p&gt;BTW，一篇不可多得的入门Vim的好文：[简明 Vim 练级攻略]。&lt;/p&gt;
&lt;h2 id=&quot;一份好的Tmux配置文件&quot;&gt;&lt;a href=&quot;#一份好的Tmux配置文件&quot; class=&quot;headerlink&quot; title=&quot;一份好的Tmux配置文件&quot;&gt;&lt;/a&gt;一份好的Tmux配置文件&lt;/h2&gt;&lt;p&gt;曾经我使用iTerm的一个主要原因是它可以方便的横竖分屏，直到我发现了[tmux]。这里不做tmux的介绍。一份好的tmux config file更是能让你如虎添翼。&lt;/p&gt;
&lt;p&gt;如果你对如何配置tmux还比较生疏，不放先去读一读[别人]的[配置文件]，简单做一些配置，使用一段时间，逐渐成为老司机后，再做更详细、全面，符合自己使用习惯的配置。&lt;/p&gt;
&lt;p&gt;如果你碰巧跟我一样有两台Mac，使用iCloud Drive或者其它云同步平台同步这些杂七杂八的配置文件是个不错的选择。&lt;/p&gt;
&lt;p&gt;以iCloud Drive为例，新建一个MacConfig文件夹，用于保存需要同步的配置文件，然后把tmux的配置文件放到这个目录下，命名为&lt;code&gt;tmux.conf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/alfred_4.png&quot; alt=&quot;tmux&quot;&gt;&lt;/p&gt;
&lt;p&gt;之后在用户目录建立一个指向这个配置文件的软连接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ln -s ~/Library/Mobile\ Documents/com~apple~CloudDocs/MacConfig/tmux.conf .tmux.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在另一台Mac上建立同样的软连接，即实现了同步。&lt;/p&gt;
&lt;p&gt;工欲善其事必先利其器，祝玩得开心。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近用的几件利器，大大提高了我的工作效率。&lt;/p&gt;
    
    </summary>
    
      <category term="工具集" scheme="http://blog.liushuaiko.be/categories/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="Alfred" scheme="http://blog.liushuaiko.be/tags/Alfred/"/>
    
      <category term="vim" scheme="http://blog.liushuaiko.be/tags/vim/"/>
    
      <category term="tmux" scheme="http://blog.liushuaiko.be/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>与Clang共舞 —— __attribute__</title>
    <link href="http://blog.liushuaiko.be/blog/2016/08/03/clang-attribute/"/>
    <id>http://blog.liushuaiko.be/blog/2016/08/03/clang-attribute/</id>
    <published>2016-08-03T13:53:28.000Z</published>
    <updated>2016-08-03T13:59:17.000Z</updated>
    
    <content type="html">&lt;p&gt;__attribute__是一个编译器指令，用于在C、C++、Objective-C中修饰变量、函数、参数、方法、类等。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;使用-attribute&quot;&gt;&lt;a href=&quot;#使用-attribute&quot; class=&quot;headerlink&quot; title=&quot;使用__attribute__&quot;&gt;&lt;/a&gt;使用__attribute__&lt;/h2&gt;&lt;p&gt;合理使用__attribute__有什么好处？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给编译器提供上下文，帮助编译器做优化，合理使用可以收到显著的优化效果&lt;/li&gt;
&lt;li&gt;编译器会根据__attribute__产生一些编译警告，使代码更规范&lt;/li&gt;
&lt;li&gt;给代码阅读者提供必要的注解，助其理解代码意图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之，__attribute__起到了给编译器提供上下文的作用。任何可以给编译器提供一些额外的信息的机会，都应该把握住。但是务必要记住，当不确定是否该添加__attribute__或者不知道是否用对了__attribute__时，果断删掉吧，因为提供了错误的上下文，还不如不提供，由此引起的错误通常很难被发现。&lt;/p&gt;
&lt;h2 id=&quot;一些核心的-attribute&quot;&gt;&lt;a href=&quot;#一些核心的-attribute&quot; class=&quot;headerlink&quot; title=&quot;一些核心的__attribute__&quot;&gt;&lt;/a&gt;一些核心的__attribute__&lt;/h2&gt;&lt;p&gt;很多编译器和平台都支持__attribute__，了解每个平台上每种架构的每个__attribute__指令的ROI太低了，我们选一些较为常用的添加到工具包里，就能事半功倍。&lt;/p&gt;
&lt;h3 id=&quot;attribute-objc-requires-super&quot;&gt;&lt;a href=&quot;#attribute-objc-requires-super&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((objc_requires_super))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((objc_requires_super))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用于修饰一个方法，向编译器表明，当子类覆盖这个方法时，必须要调用super。但是这个指令不制约调用super的位置，编译器仅检查调用与否。&lt;/p&gt;
&lt;p&gt;比如在覆盖&lt;code&gt;dealloc&lt;/code&gt;方法时，我们会在最后调用&lt;code&gt;[super dealloc]&lt;/code&gt;，这是满足requires super要求的。&lt;/p&gt;
&lt;p&gt;Foundation里提供了宏&lt;code&gt;NS_REQUIRES_SUPER&lt;/code&gt;，详见NSObjcRuntime.h。&lt;/p&gt;
&lt;h3 id=&quot;attribute-unused&quot;&gt;&lt;a href=&quot;#attribute-unused&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((unused))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((unused))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用于修饰一个变量或函数，表明变量或函数可能暂时没用到，但是为了代码的扩展性或者其它原因是有用的，请求编译器不要产生编译警告。&lt;/p&gt;
&lt;h3 id=&quot;attribute-sentinel&quot;&gt;&lt;a href=&quot;#attribute-sentinel&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((sentinel))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((sentinel))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;sentinel这个英文单词是「哨兵」的意思，其用于修饰一个接收可变参数的方法或函数，表达方法或函数最后一个参数需为nil的诉求。&lt;/p&gt;
&lt;p&gt;BTW，可以用&lt;code&gt;__attribute__((sentinel(index))&lt;/code&gt;来标明需要&lt;strong&gt;倒数&lt;/strong&gt;第&lt;code&gt;index&lt;/code&gt;个参数为nil。&lt;/p&gt;
&lt;p&gt;例子参见&lt;code&gt;NSArray&lt;/code&gt;的&lt;code&gt;initWithObjects:&lt;/code&gt;方法，Foundation里面提供了宏&lt;code&gt;NS_REQUIRES_NIL_TERMINATION&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;attribute-const&quot;&gt;&lt;a href=&quot;#attribute-const&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((const))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((const))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用于修饰一个方法或者函数，表明这个函数不去检测和修改任何东西或状态，它的返回值只依赖函数的参数。参数是引用传递的函数务必不要使用这个attribute，类似，如果函数里面调用了非const的函数，也禁止使用这个attribute，注意这里用「禁止」这个词不太确切，大意是这类函数压根就不是const的函数，用了必然会出错。另外如果这个attribute用在了一个没有返回值的函数上，也是没有意义的。&lt;/p&gt;
&lt;p&gt;例如&lt;code&gt;int square(int n) __attribute__((const));&lt;/code&gt;，这个求平方的函数，就是一个const函数。它的返回值就只跟参数n有关系，无需检测什么，传过来6，返回值永远是常量36。&lt;/p&gt;
&lt;p&gt;如果指定了高度优化的编译选项，通常编译器会把const函数调用的参数和结果缓存起来以提高性能。这也是这个attribute用错会很难debug的原因，因为可能编译器不会在DEBUG模式下做编译优化，导致函数的每次调用是正确的，而在RELEASE模式下，经过优化的代码执行时，把一个不是const的函数的执行结果缓存起来，出现诡异的bug，甚至需要去看汇编代码才能找出问题。&lt;/p&gt;
&lt;p&gt;另有&lt;code&gt;__attribute__((pure))&lt;/code&gt;，比const条件稍微宽松一些，标明了函数除了依赖其参数外，还可以依赖一些global/static的变量。&lt;/p&gt;
&lt;p&gt;推荐所有单例类的&lt;code&gt;sharedInstance&lt;/code&gt;方法都使用const注解。此外，如果一个类的类方法经常被调用而且是const或者pure，那么不妨把它用纯C函数实现，会有不错的性能提升。&lt;/p&gt;
&lt;h2 id=&quot;跟内存管理相关的-attribute&quot;&gt;&lt;a href=&quot;#跟内存管理相关的-attribute&quot; class=&quot;headerlink&quot; title=&quot;跟内存管理相关的__attribute__&quot;&gt;&lt;/a&gt;跟内存管理相关的__attribute__&lt;/h2&gt;&lt;h3 id=&quot;attribute-objc-precise-lifetime&quot;&gt;&lt;a href=&quot;#attribute-objc-precise-lifetime&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((objc_precise_lifetime))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((objc_precise_lifetime))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用这个attribute修饰一个变量，防止ARC过早释放它。即向编译器表明，变量在它所处的整个作用域内，都应被认为是有用的。&lt;/p&gt;
&lt;p&gt;Foundation里提供了宏&lt;code&gt;NS_VALID_UNTIL_END_OF_SCOPE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;看下面的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)foo &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NS_VALID_UNTIL_END_OF_SCOPE MyObject *obj = [[MyObject alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSValue *value = [NSValue valueWithPointer:obj];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果没有前面的修饰符，&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// obj可能在高度优化编译过的程序里，被放在NSValue里之后就会被ARC释放了&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 下面再去访问obj就会crash&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MyObject *objAgain = [value pointerValue];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    objAgain.bar();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;attribute-objc-returns-inner-pointer&quot;&gt;&lt;a href=&quot;#attribute-objc-returns-inner-pointer&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((objc_returns_inner_pointer))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((objc_returns_inner_pointer))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用于修饰一个方法，防止ARC过早释放这个方法的所有者。Foundation里提供了宏&lt;code&gt;NS_RETURNS_INNER_POINTER&lt;/code&gt;，顾名思义，它标明了这个方法返回了一个指向方法所有者自身或其内部内存的指针，有点绕，例子见&lt;code&gt;NSMutableData&lt;/code&gt;里的&lt;code&gt;mutableBytes&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;看个具体的例子。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSMutableData *buffer = [[NSMutableData alloc] initWithLength:&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// mutableBytes返回了一个指向buffer内部内存的指针&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* cBuffer = buffer.mutableBytes;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果没有NS_RETURNS_INNER_POINTER修饰&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 到此为止ARC可能销毁buffer&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 那么后续对cBuffer的操作可能会导致crash&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;memcpy&lt;/span&gt;(cBuffer, &lt;span class=&quot;string&quot;&gt;&quot;1234567&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;attribute-ns-returns-retained&quot;&gt;&lt;a href=&quot;#attribute-ns-returns-retained&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((ns_returns_retained))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((ns_returns_retained))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;在Objective-C里，很多方法的命名都是有约定的含义的。比如以&lt;code&gt;alloc&lt;/code&gt;、&lt;code&gt;new&lt;/code&gt;、&lt;code&gt;copy&lt;/code&gt;、&lt;code&gt;mutableCopy&lt;/code&gt;开头的方法，会返回一个retain count为1的对象。对于那些未遵守这些约定，却做了类似操作的方法，可以使用&lt;code&gt;__attribute__((ns_returns_retained))&lt;/code&gt;来标明，但如果方法遵守了命名约定，就不必再修饰。&lt;/p&gt;
&lt;p&gt;另见：&lt;br&gt;&lt;code&gt;__attribute__((objc_method_family(X)))&lt;/code&gt;&lt;br&gt;&lt;code&gt;__attribute__((ns_returns_not_retained))&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;attribute-ns-consumes-self&quot;&gt;&lt;a href=&quot;#attribute-ns-consumes-self&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((ns_consumes_self))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((ns_consumes_self))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用于修饰一个方法，表明这个方法&lt;strong&gt;可能&lt;/strong&gt;会更把消息接受者换成另一个对象，并使消息接收者的retain count为0。例子见&lt;code&gt;NSObject&lt;/code&gt;里的&lt;code&gt;awakeAfterUsingCoder:&lt;/code&gt;方法；如有必要，请稍微读一下文档。&lt;/p&gt;
&lt;p&gt;Foundation里面提供了这个attribute的宏&lt;code&gt;NS_REPLACES_RECEIVER&lt;/code&gt;，它的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; NS_REPLACES_RECEIVER __attribute__((ns_consumes_self)) NS_RETURNS_RETAINED&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;attribute-objc-arc-weak-reference-unavailable&quot;&gt;&lt;a href=&quot;#attribute-objc-arc-weak-reference-unavailable&quot; class=&quot;headerlink&quot; title=&quot;__attribute__((objc_arc_weak_reference_unavailable))&quot;&gt;&lt;/a&gt;&lt;code&gt;__attribute__((objc_arc_weak_reference_unavailable))&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;用于修饰一个类，标明这个类不支持对它实例的弱引用。&lt;/p&gt;
&lt;h2 id=&quot;其它有用的-attribute&quot;&gt;&lt;a href=&quot;#其它有用的-attribute&quot; class=&quot;headerlink&quot; title=&quot;其它有用的__attribute__&quot;&gt;&lt;/a&gt;其它有用的__attribute__&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__attribute__((constructor(…)))&lt;/code&gt;和&lt;code&gt;__attribute__((destructor(…)))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__attribute__((enable_if(…)))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__attribute__((cleanup))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.twitter.com/2014/attribute-directives-in-objective-c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;__attribute__ directives in Objective-C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nshipster.com/__attribute__/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;__attribute__&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://clang.llvm.org/docs/AttributeReference.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Clang Attribute Doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Attribute-Syntax.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GCC Attribute doc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;__attribute__是一个编译器指令，用于在C、C++、Objective-C中修饰变量、函数、参数、方法、类等。&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计语言" scheme="http://blog.liushuaiko.be/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Clang" scheme="http://blog.liushuaiko.be/tags/Clang/"/>
    
      <category term="attribute" scheme="http://blog.liushuaiko.be/tags/attribute/"/>
    
  </entry>
  
  <entry>
    <title>KBtalKing Race II按键编程手记</title>
    <link href="http://blog.liushuaiko.be/blog/2016/07/24/kbtalking-programing/"/>
    <id>http://blog.liushuaiko.be/blog/2016/07/24/kbtalking-programing/</id>
    <published>2016-07-24T14:51:43.000Z</published>
    <updated>2016-07-24T14:55:51.000Z</updated>
    
    <content type="html">&lt;p&gt;入手这款红轴机械键盘已经一年半多了，直到最近才掌握了它的自定义按键编程技巧。前几天得知，这个键盘居然停产了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/IMG_0009.JPG&quot; alt=&quot;keyboard&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;按键编程&quot;&gt;&lt;a href=&quot;#按键编程&quot; class=&quot;headerlink&quot; title=&quot;按键编程&quot;&gt;&lt;/a&gt;按键编程&lt;/h2&gt;&lt;p&gt;所谓按键编程，就是让一个按键在与功能键&lt;code&gt;Pn&lt;/code&gt;一起按下时，响应为一些按键的组合。通过这种方式，把我们经常需要输入的文字内容简化为一次按键即可输入完成，大大提高了工作效率。&lt;/p&gt;
&lt;p&gt;有人提到为什么不使用输入法的自定义短语？好吧，输入法自定义短语的前提是“输入法”，按键编程只需要键盘。&lt;/p&gt;
&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h2&gt;&lt;p&gt;假设我们想达到，按&lt;code&gt;Pn + P&lt;/code&gt;，响应为&lt;code&gt;ggpull&lt;/code&gt;的目的，那么操作步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按&lt;code&gt;Fn + 右侧Ctrl&lt;/code&gt;，进入编程模式，此时键盘按键灯熄灭，Pn灯闪烁&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;P&lt;/code&gt;，此时，Pn灯常亮&lt;/li&gt;
&lt;li&gt;依次按下&lt;code&gt;G&lt;/code&gt;、&lt;code&gt;G&lt;/code&gt;、&lt;code&gt;P&lt;/code&gt;、&lt;code&gt;U&lt;/code&gt;、&lt;code&gt;L&lt;/code&gt;、&lt;code&gt;L&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;Fn&lt;/code&gt;，结束编程，Pn灯闪烁&lt;/li&gt;
&lt;li&gt;如果想继续给其它按键编程，重复2-4即可，否则按&lt;code&gt;Fn + 右侧Ctrl&lt;/code&gt;，Pn灯熄灭，编程结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试一下，按住&lt;code&gt;Pn&lt;/code&gt;，同时按下&lt;code&gt;P&lt;/code&gt;，&lt;code&gt;ggpull&lt;/code&gt;在屏幕上回显了。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h2&gt;&lt;p&gt;我使用的是zsh作为终端，oh-my-zsh作为配置，在终端输入&lt;code&gt;zsh_stats&lt;/code&gt;，可以列出最常输入的20个命令，选择一些使用上述方式简化输入吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;入手这款红轴机械键盘已经一年半多了，直到最近才掌握了它的自定义按键编程技巧。前几天得知，这个键盘居然停产了。&lt;/p&gt;
    
    </summary>
    
      <category term="工具集" scheme="http://blog.liushuaiko.be/categories/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="KBtalKing" scheme="http://blog.liushuaiko.be/tags/KBtalKing/"/>
    
  </entry>
  
  <entry>
    <title>Swift中Optional的map和flatMap</title>
    <link href="http://blog.liushuaiko.be/blog/2016/07/13/swift-optional-map/"/>
    <id>http://blog.liushuaiko.be/blog/2016/07/13/swift-optional-map/</id>
    <published>2016-07-13T14:31:57.000Z</published>
    <updated>2016-07-13T14:36:37.000Z</updated>
    
    <content type="html">&lt;p&gt;用过Swift的读者想必对&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;flatMap&lt;/code&gt;不陌生，它们定义在&lt;code&gt;SequenceType&lt;/code&gt;协议及其extension中，讲它们用法的文章一大堆，我就不拾人牙慧了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;但是不知读者是否知道，Swift中的Optional类型，也有&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;flatMap&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;首先看这样的场景：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; avatarURL: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;? = &lt;span class=&quot;string&quot;&gt;&quot;http://blog.liushuaiko.be/images/avatar.PNG&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不妨假设&lt;code&gt;avatarURL&lt;/code&gt;的来源以及是否有值我们不得而知，因此我们将其定义为一个&lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt;类型。在使用它时，我们需要做一系列的判断赋值：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; _avatarURL = avatarURL &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; url = &lt;span class=&quot;type&quot;&gt;NSURL&lt;/span&gt;(string: _avatarURL) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(url.absoluteString)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样的场景通常在解析网络请求返回的JSON时很常见，不知不觉就出现了所谓的「大括号阶梯」。&lt;/p&gt;
&lt;p&gt;我们可以用Optional类型中定义的&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;flatMap&lt;/code&gt;来避免这种情况，先看下用了之后会变成什么样子：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;avatarURL.flatMap &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;NSURL&lt;/span&gt;(string: $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;($&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.absoluteString)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;打开&lt;code&gt;Optional&lt;/code&gt;的定义，&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;flatMap&lt;/code&gt;一览无余，你应该顺便发现，Optional在Swift里是一个enum。&lt;/p&gt;
&lt;p&gt;去掉&lt;code&gt;@noescape&lt;/code&gt;和&lt;code&gt;throws&lt;/code&gt;，它们的原型更加清晰：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;map&lt;/span&gt;&amp;lt;U&amp;gt;&lt;span class=&quot;params&quot;&gt;(f: Wrapped -&amp;gt; U)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;U&lt;/span&gt;?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;flatMap&lt;/span&gt;&amp;lt;U&amp;gt;&lt;span class=&quot;params&quot;&gt;(f: Wrapped -&amp;gt; U?)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;U&lt;/span&gt;?&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这两个泛型函数中，&lt;code&gt;Wrapped&lt;/code&gt;是Optional的泛型参数，即Optional包裹的类型。两个函数唯一的不同是接收的参数「函数的返回值」不同，一个期待函数返回&lt;code&gt;U&lt;/code&gt;，另一个期待函数返回&lt;code&gt;U?&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;两个函数在表现上是类似的，如果可选类型有值（!= nil），则返回&lt;code&gt;f(Wrapped Value)&lt;/code&gt;，否则直接返回nil。&lt;/p&gt;
&lt;p&gt;那么不难理解前面的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; url:&lt;span class=&quot;type&quot;&gt;NSURL&lt;/span&gt;? = avatarURL.flatMap &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;NSURL&lt;/span&gt;(string: $&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// NSURL? 相当于 U?&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; nothing:&lt;span class=&quot;type&quot;&gt;Optional&lt;/span&gt; = url.&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;($&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.absoluteString) &lt;span class=&quot;comment&quot;&gt;// 什么都不返回，因此这个map返回一个什么都不包裹的Optional&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;用过Swift的读者想必对&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;flatMap&lt;/code&gt;不陌生，它们定义在&lt;code&gt;SequenceType&lt;/code&gt;协议及其extension中，讲它们用法的文章一大堆，我就不拾人牙慧了。&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计语言" scheme="http://blog.liushuaiko.be/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Swift" scheme="http://blog.liushuaiko.be/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>高级Auto Layout笔记</title>
    <link href="http://blog.liushuaiko.be/blog/2016/07/09/advanced-autolayout/"/>
    <id>http://blog.liushuaiko.be/blog/2016/07/09/advanced-autolayout/</id>
    <published>2016-07-09T06:44:50.000Z</published>
    <updated>2016-07-13T14:38:02.000Z</updated>
    
    <content type="html">&lt;p&gt;本文是objc.io中「Advanced Auto Layout Toolbox」的学习笔记。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Auto Layout，想说爱你不容易。&lt;/p&gt;
&lt;h3 id=&quot;1-布局过程&quot;&gt;&lt;a href=&quot;#1-布局过程&quot; class=&quot;headerlink&quot; title=&quot;1. 布局过程&quot;&gt;&lt;/a&gt;1. 布局过程&lt;/h3&gt;&lt;p&gt;在使用了Auto Layout情况下，View显示到屏幕上分为3个阶段：&lt;/p&gt;
&lt;p&gt;约束计算：发生自子View-&amp;gt;父View。通过显式调用&lt;code&gt;setNeedsUpdateConstraints&lt;/code&gt;来触发这个过程，实际上更改约束会自动触发这个过程。在自定义View中，可以覆盖&lt;code&gt;updateConstraints&lt;/code&gt;来添加或变更约束。&lt;br&gt;布局：发生自父View-&amp;gt;子View。将1中计算的结果，应用到View的frame上。通过显式调用&lt;code&gt;setNeedsLayout&lt;/code&gt;来触发这个过程，这个函数很廉价，因为所有的布局请求都会合并成一个layout过程去做。当然，可以通过调用&lt;code&gt;layoutIfNeeded&lt;/code&gt;来迫使系统立刻更新布局。在自定义View中，可以通过覆盖&lt;code&gt;layoutSubviews&lt;/code&gt;方法来hook这个过程。&lt;br&gt;展示：这个过程与是否使用了Auto Layout无关。发生自父View-&amp;gt;子View。通过显式调用&lt;code&gt;setNeedsDisplay&lt;/code&gt;来触发这个过程，视图的绘制过程也会被合并。类似地，可以覆盖&lt;code&gt;drawRect:&lt;/code&gt;来hook这个过程。&lt;/p&gt;
&lt;p&gt;以上三个阶段是依次发生的，每一步都会依赖它的前一步。要注意，以上三个阶段这是一个迭代的过程，比如布局阶段可能触发了另一个约束计算的过程，这个计算过程又触发了新的布局过程等等。&lt;/p&gt;
&lt;h3 id=&quot;2-Intrinsic-Content-Size&quot;&gt;&lt;a href=&quot;#2-Intrinsic-Content-Size&quot; class=&quot;headerlink&quot; title=&quot;2. Intrinsic Content Size&quot;&gt;&lt;/a&gt;2. Intrinsic Content Size&lt;/h3&gt;&lt;p&gt;Intrinsic这个词的意思，「本质的、固有的」。一个View的Intrinsic Content Size意指这个View想要舒舒服服地显示出来，需要多大的size。对于一个&lt;code&gt;numberOfLines&lt;/code&gt;为0的Label来说，它的&lt;code&gt;preferredMaxLayoutWidth&lt;/code&gt;确定、font确定，则它的&lt;code&gt;intrinsicContentSize&lt;/code&gt;就定下来了。不是所有的View都有&lt;code&gt;intrinsicContentSize&lt;/code&gt;，在自定义的View中，可以覆盖&lt;code&gt;intrinsicContentSize&lt;/code&gt;方法来返回Intrinsic Content Size，并可以通过调用&lt;code&gt;invalidateIntrinsicContentSize&lt;/code&gt;来通知布局系统在下一个布局过程采用新的Intrinsic Content Size。&lt;/p&gt;
&lt;h3 id=&quot;3-Compression-Resistance-和-Content-Hugging&quot;&gt;&lt;a href=&quot;#3-Compression-Resistance-和-Content-Hugging&quot; class=&quot;headerlink&quot; title=&quot;3. Compression Resistance 和 Content Hugging&quot;&gt;&lt;/a&gt;3. Compression Resistance 和 Content Hugging&lt;/h3&gt;&lt;p&gt;首先明确：这两个属性都是讨论的前提是View在相应的维度有Intrinsic Content Size。实际上，这两个属性和Intrinsic Content Size都是被翻译成约束来实现的。举个例子（请务必多读几遍这个例子）：假设一个Label的Intrinsic Content Size是{100, 30}，它在水平和竖直方向上的Compression Resistance优先级是750，在水平和竖直方向的Content Hugging优先级是250，那么这些被转成了如下约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;H:[label(&amp;lt;=100@250)]
H:[label(&amp;gt;=100@750)]
V:[label(&amp;lt;=30@250)]
V:[label(&amp;gt;=30@750)]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-Alignment-Rect&quot;&gt;&lt;a href=&quot;#4-Alignment-Rect&quot; class=&quot;headerlink&quot; title=&quot;4. Alignment Rect&quot;&gt;&lt;/a&gt;4. Alignment Rect&lt;/h3&gt;&lt;p&gt;Auto Layout操作的是View的Alignment Rect，不是View的Frame。这是个伟大的概念，用于把View的布局和显示解耦，虽然大部分情况它们是相等的。同样，View的Intrinsic Content Size也指的是Alignment Rect。在View有阴影、自定义Badge时，这个概念会很有用。在自定义的View中，可以通过覆盖&lt;code&gt;alignmentRectInsets&lt;/code&gt;，来返回在特定的Frame下，Alignment Rect的edge insets是多少。还可以覆盖&lt;code&gt;alignmentRectForFrame:&lt;/code&gt;和&lt;code&gt;frameForAlignmentRect:&lt;/code&gt;来实现更精细的控制，蛋这两个方法必须互为反函数。&lt;/p&gt;
&lt;h3 id=&quot;5-其它&quot;&gt;&lt;a href=&quot;#5-其它&quot; class=&quot;headerlink&quot; title=&quot;5. 其它&quot;&gt;&lt;/a&gt;5. 其它&lt;/h3&gt;&lt;p&gt;如果自定义的View是基于Auto Layout封装，那么它就不能在未开启Auto Layout的Window上使用，因此最好覆盖View的&lt;code&gt;requiresConstraintBasedLayout&lt;/code&gt;，返回YES来宣称这件事。&lt;br&gt;程序挂掉：NSInternalInconsistencyException, reason: ‘Auto Layout still required after executing -layoutSubviews. 原因通常因为是我们在第2个阶段（布局阶段）更改了约束，这通常是在被覆盖的&lt;code&gt;layoutSubviews&lt;/code&gt;方法里做的，这触发了第1个阶段，但是却没有再次触发布局阶段。通常的解决办法是在更改约束后再次调用&lt;code&gt;[super layoutSubviews]&lt;/code&gt;来显式触发布局过程。&lt;br&gt;Auto Layout的性能：&lt;a href=&quot;http://floriankugler.com/2013/04/22/auto-layout-performance-on-ios/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://floriankugler.com/2013/04/22/auto-layout-performance-on-ios/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文是objc.io中「Advanced Auto Layout Toolbox」的学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="移动互联网开发" scheme="http://blog.liushuaiko.be/categories/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.liushuaiko.be/tags/iOS/"/>
    
      <category term="AutoLayout" scheme="http://blog.liushuaiko.be/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>日本关西游记</title>
    <link href="http://blog.liushuaiko.be/blog/2016/07/09/japan-kansai/"/>
    <id>http://blog.liushuaiko.be/blog/2016/07/09/japan-kansai/</id>
    <published>2016-07-09T06:44:29.000Z</published>
    <updated>2016-07-09T06:50:45.000Z</updated>
    
    <content type="html">&lt;p&gt;前段时间到日本关西地区玩了几天，发现了日本一些耐人寻味的细节。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;秩序。日本人乘坐上下楼扶梯都是单人靠一侧，让出一个过道给那些赶时间的人快速行走。虽然所在地不同靠左还是靠右不一定，但是几乎看不到有人站成一排堵住扶梯。&lt;/li&gt;
&lt;li&gt;礼仪。日本的服务业很发达，商场、地铁、酒店的服务员全都笑脸相迎，“阿狸嘎豆”说个不停，而且说的时候会点头示意，甚至鞠躬的也不在少数，在这种氛围下你也会不自觉变得更有礼貌，并觉得钱花的很舒服。曾在公交车上见到了一个很萌很有意思的公益广告，旨在提醒乘客在使用耳机时，注意耳机的漏音打扰到身边的人，这个细节着实震撼到我了。&lt;/li&gt;
&lt;li&gt;内敛。在街上很少见到豪车，大多数是日系简单实用的轿车，也很少见到外形夸张的豪宅，倒是雅致精巧的小木屋很常见，屋门口大多摆放着精心侍弄的花卉和盆景，人们衣着朴实，讲话声音很小，街上的女人都带着妆容，涂着红腮，即便是老妇人也不例外，这使得你一眼就能看出哪些是游客，哪些是当地人。&lt;/li&gt;
&lt;li&gt;完善。公共场所无障碍指示标识随处可见，几乎每个公共卫生间都有无障碍设施，公交车在停车上下客时，车身会向门的一侧倾斜以方便乘客上下车，在停车场或者建筑工地等车辆频繁出入的门口，会有专人看守，控制车辆，在没人经过的时候才放行车辆。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，在Apple Store见到Apple TV，在街上看到人们刷Twitter，在电子用品商场见到Chromecast和装着原生Android的Nexus手机，刚开始居然会觉得不适应，然后一下子明白，这很正常。&lt;/p&gt;
&lt;p&gt;不舒服的地方？也有。逆行的人也很多，车辆不会主动让行人，我到过的几个地方没有禁摩托车，经常会有年轻人骑着摩托轰着油门经过，多普勒效应尤为刺耳。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间到日本关西地区玩了几天，发现了日本一些耐人寻味的细节。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.liushuaiko.be/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="日本" scheme="http://blog.liushuaiko.be/tags/%E6%97%A5%E6%9C%AC/"/>
    
      <category term="关西" scheme="http://blog.liushuaiko.be/tags/%E5%85%B3%E8%A5%BF/"/>
    
  </entry>
  
  <entry>
    <title>2015，永远年轻，永远热泪盈眶</title>
    <link href="http://blog.liushuaiko.be/blog/2015/12/30/my-2015/"/>
    <id>http://blog.liushuaiko.be/blog/2015/12/30/my-2015/</id>
    <published>2015-12-30T11:34:56.000Z</published>
    <updated>2016-07-09T06:07:35.000Z</updated>
    
    <content type="html">&lt;p&gt;这一年，在 AliExpress 度过了完整的一年。&lt;/p&gt;
&lt;p&gt;这一年，感触、思考、压力、挑战、完美、不完美，就像落下的雨点，大珠小珠落玉盘。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;embed src=&quot;http://www.xiami.com/widget/40156335_1772001102/singlePlayer.swf&quot; type=&quot;application/x-shockwave-flash&quot; width=&quot;257&quot; height=&quot;33&quot; wmode=&quot;transparent&quot;&gt;

&lt;p&gt;就从换房子开始吧。&lt;/p&gt;
&lt;p&gt;在豆瓣上认识了跟我年纪相仿的小王同学，我们一起看了很多房子，在这个过程中我学会了如何去判断一个房子的好坏、性价比高低，对公司附近的小区的了如指掌。虽然最后由于种种原因没有一起合租，但是这真是一段很令人难忘的经历。最后我们租的房子都还不错，我找到了公司附近的 CBD 旁边的一个小区，对我来说可能是公司附近最好的小区了。&lt;/p&gt;
&lt;p&gt;如果让我周末在家里呆一天，看一天电视，那么晚上回顾这一天，我肯定会有一种浪费生命罪恶感，甚至会为之抓狂。但是更罪恶的是，如果这一天让我在外面暴走，哪怕什么都不干，没有一点收获，我居然会觉得很充实。好吧，5月份之前，几乎每周末都会找一下午，约上震宇兄去西湖，绕着西湖溜达溜达，看场电影，一起吃个晚饭，随便扯扯。吃完饭各自回家前，我们会在马路边，在天桥上，甚至在公交车站，旁若无人地大声喊上一句：“fxxk，明天又要上班了！”&lt;/p&gt;
&lt;p&gt;有一段时间的周末，我们迷上了一个 iPad 上的密室逃脱游戏，我们找了一个很偏僻的星巴克，断断续续，花了还挺久的，给刷通关了，然后通过玩这个游戏发现，自己居然不算太笨。&lt;/p&gt;
&lt;p&gt;接着，5月末，震宇兄被变化到滨江了。我凭借着丰富的找房经验，给他不停地推荐我住的小区的房子。最后，如我所愿，震宇兄还真跟我住到了同一个小区。&lt;/p&gt;
&lt;p&gt;在接下来的周末里，how could you believe that…&lt;/p&gt;
&lt;p&gt;骑自行车去钱塘江边，把即兴在地摊上买的小风筝在喝一口水的功夫内放丢，然后在某宝上买了一个3倍大的风筝，最终放飞;&lt;br&gt;在1688上批发了一批儿童小飞碟，类似竹蜻蜓的东西，到 CBD 去卖，巧妙与 cops 周旋，最终盈亏平衡；&lt;br&gt;逢热片必坐地铁穿过钱塘江去一个人少价低环境好的电影院看了它，回去的路上一路狂喷；&lt;br&gt;自己做晚饭，震宇兄秀刀工手被割伤两次；&lt;br&gt;在公司锁上自行车后才发现没带钥匙;&lt;br&gt;God damn insane！&lt;/p&gt;
&lt;h3 id=&quot;程序猿&quot;&gt;&lt;a href=&quot;#程序猿&quot; class=&quot;headerlink&quot; title=&quot;程序猿&quot;&gt;&lt;/a&gt;程序猿&lt;/h3&gt;&lt;p&gt;前几天大飞问我，说你现在不停地做需求做业务，也没时间钻研一些新技术吧。&lt;/p&gt;
&lt;p&gt;我想了想，一切脱离业务的技术都是耍流氓。技术不能凭空产生，一定得先有业务需求（广义上的）才会有技术。一定不要只完成某个需求，而要把它做好，做精。在这方面我一直觉得我做的还是不错的，总是能在完成需求的过程中迸发出很多点子，也总是能尝试一些新的东西，效果还不错。&lt;/p&gt;
&lt;p&gt;上半年一直投入在 iPad App 的开发。可以说这是我技术提升的踏板。因为种种原因我在 iPad App 上的「权力」还是比较大的，带我的小伙技术也非常扎实，跟着他做了不少，也学了不少。&lt;/p&gt;
&lt;p&gt;我们一起提高 App 质量，改进开发流程，优化 App 性能，产出了很多质量还不错的组件，在这个过程中我也渐渐熟悉公司的业务，熟悉 iOS 开发的套路，熟悉一个需求的生命周期，处处留心皆学问。&lt;/p&gt;
&lt;p&gt;九月份开始转投 iPhone 的开发，开发了一个模块，做了一个很核心的业务，有了 iPad 的基础，开发起来还算顺手。&lt;/p&gt;
&lt;p&gt;当然，今年也自学了一些东西。能想起来的就 Core Animation 和 Swfit 了。今年买了苹果的开发者资格，自学 Swift 写了一个看妹子的 App，最终因为某些原因没通过审核，但是当我照例晒到朋友圈时，Fenng 居然给我点了赞，在 GitHub 上发的时候，onevcat 还 star 了，这些都是很哦妹子嘤的经历。&lt;/p&gt;
&lt;h3 id=&quot;双十一&quot;&gt;&lt;a href=&quot;#双十一&quot; class=&quot;headerlink&quot; title=&quot;双十一&quot;&gt;&lt;/a&gt;双十一&lt;/h3&gt;&lt;p&gt;记得大一时，一天晚上，熄灯后，都准备睡觉时，彪彪还在那玩电脑，鼠标啪啪点个不停，一脸兴奋的告诉我们，光棍节，某宝在各种促销，都玩疯了！原来这货还在买球鞋。&lt;/p&gt;
&lt;p&gt;5年后，十一黄金周前夕，我结束了4天的休假，赶回公司，加班准备双十一。&lt;/p&gt;
&lt;p&gt;后面一段时间，整个 Team 都很累。&lt;/p&gt;
&lt;p&gt;大促 App 发布当晚，看得出来，大家都像刚改造好放出来一样，以自己的方式释放着压力。然而，居然发现了一个挺严重的 bug，我的。坦率地讲，当时很慌，顶着巨大的压力修复，进入了新的一轮打包过程……&lt;/p&gt;
&lt;p&gt;发布后第二天中午，哦不，当天，我们凌晨3点回去的，我们去公司旁一家小店吃了寿司，随便扯扯淡，轻松的感觉，久违了。&lt;/p&gt;
&lt;p&gt;双十一对我来说是一次考验也是一次历练，那时候第一次有种真真切切的，我在做一些事情，我在创造价值的感觉，哦妹子嘤。&lt;/p&gt;
&lt;h3 id=&quot;买买买&quot;&gt;&lt;a href=&quot;#买买买&quot; class=&quot;headerlink&quot; title=&quot;买买买&quot;&gt;&lt;/a&gt;买买买&lt;/h3&gt;&lt;p&gt;一次跟朋友闲扯，得出一个结论，干这一行好尴尬，赚的钱吧，不太容易让孩子成为富二代，但也不至于生活的太差。这个结论真是太对了。&lt;/p&gt;
&lt;p&gt;今年买了很多东西，捷安特自行车、Dell U2515H、电动牙刷，坚果手机，甚至萌生了把小时候因为父母给的钱不够买不起的小玩意儿都买回来的想法[doge脸]。&lt;/p&gt;
&lt;p&gt;此外，今年买了很多 App，买了很多 Service，VPS 、GitHub 私有 repo 等等，这也是工作后观念的一个转变，免费的总是最贵的。&lt;/p&gt;
&lt;p&gt;上半年的股市热，我买了点基金，以另一种方式参与到了炒股的大潮中，结局能猜到，很惨。好在没投太多，因此损失不是特别大，但是整件事情让我明白是该学学经济、理财方面的知识了。&lt;/p&gt;
&lt;h3 id=&quot;其它&quot;&gt;&lt;a href=&quot;#其它&quot; class=&quot;headerlink&quot; title=&quot;其它&quot;&gt;&lt;/a&gt;其它&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;年度必看国产剧：《琅琊榜》&lt;/li&gt;
&lt;li&gt;年度必看美剧：《疑犯追踪》《无耻之徒》&lt;/li&gt;
&lt;li&gt;年度可看国产电影：《烈日灼心》《老炮儿》&lt;/li&gt;
&lt;li&gt;年度必看外国电影：《火星救援》&lt;/li&gt;
&lt;li&gt;年度 iOS 开发者必用工具：FLEX&lt;/li&gt;
&lt;li&gt;年度必买 App：1Password Dash Reeder&lt;/li&gt;
&lt;li&gt;年度最不值得购买商品：坚果手机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2016&quot;&gt;&lt;a href=&quot;#2016&quot; class=&quot;headerlink&quot; title=&quot;2016&quot;&gt;&lt;/a&gt;2016&lt;/h3&gt;&lt;p&gt;目前能想到的是多学一些经济知识，还有一些设计 &amp;amp; Sketch方面的知识，技术上就不说了，因为我觉得自己总能找到一些点，做一些有趣的事情。&lt;/p&gt;
&lt;p&gt;最后，每个经历都是一次成长，希望自己能不忘初心，厚积薄发，永远年轻，永远热泪盈眶。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这一年，在 AliExpress 度过了完整的一年。&lt;/p&gt;
&lt;p&gt;这一年，感触、思考、压力、挑战、完美、不完美，就像落下的雨点，大珠小珠落玉盘。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.liushuaiko.be/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>提高工作效率篇之命令行版的 Alfred —— z</title>
    <link href="http://blog.liushuaiko.be/blog/2015/12/17/awesome-z/"/>
    <id>http://blog.liushuaiko.be/blog/2015/12/17/awesome-z/</id>
    <published>2015-12-17T11:31:38.000Z</published>
    <updated>2016-07-09T05:36:32.000Z</updated>
    
    <content type="html">&lt;p&gt; z 是一个非常 awesome 的脚本，它通过分析并记录你 &lt;code&gt;cd&lt;/code&gt; 命令的路径，建立它自己的数据索引，之后通过 z 命令可以快速跳到你想要 cd 的目录下。对于需要频繁在命令行中切换路径的工友来说，简直是神器。&lt;/p&gt;
 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;一图胜千言：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/awesome_z.gif&quot; alt=&quot;awesome_z&quot;&gt;&lt;/p&gt;
&lt;p&gt;如何安装呢？&lt;/p&gt;
&lt;p&gt;如果你用的是 zsh + oh-my-zsh，整个过程大概需要花费30秒。&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;~/.zshrc&lt;/code&gt;，找到 &lt;code&gt;plugins&lt;/code&gt;这一行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins=(git osx sublime)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加 z：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins=(git osx sublime z)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后 restart 命令行，先 cd 一番，让 z 学习一下，之后就尽情的 z 吧！&lt;/p&gt;
&lt;p&gt;如果你没有使用 zsh，或者没有使用 oh-my-zsh，稍麻烦一点点。&lt;/p&gt;
&lt;p&gt;首先去这里 &lt;a href=&quot;https://github.com/rupa/z&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/rupa/z&lt;/a&gt; 把脚本 z.sh 下载下来，之后在 &lt;code&gt;~/.zshrc&lt;/code&gt; 中加上这样的一句话，在命令行打开后执行 z：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source /path/to/z.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你甚至没有使用 zsh，那么可能要在 ~/.bashrc 里加上类似的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;. /path/to/z.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW，可以用 &lt;code&gt;z -l&lt;/code&gt; 来看目前 z 的数据情况。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; z 是一个非常 awesome 的脚本，它通过分析并记录你 &lt;code&gt;cd&lt;/code&gt; 命令的路径，建立它自己的数据索引，之后通过 z 命令可以快速跳到你想要 cd 的目录下。对于需要频繁在命令行中切换路径的工友来说，简直是神器。&lt;/p&gt;
    
    </summary>
    
      <category term="工具集" scheme="http://blog.liushuaiko.be/categories/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="z" scheme="http://blog.liushuaiko.be/tags/z/"/>
    
  </entry>
  
  <entry>
    <title>给iOS App添加基于3D touch的Quick Actions</title>
    <link href="http://blog.liushuaiko.be/blog/2015/10/28/iOS9-Quick-Actions/"/>
    <id>http://blog.liushuaiko.be/blog/2015/10/28/iOS9-Quick-Actions/</id>
    <published>2015-10-28T02:41:22.000Z</published>
    <updated>2016-07-09T05:36:16.000Z</updated>
    
    <content type="html">&lt;p&gt;3D Touch 的问世，给 iOS App 交互增加了更多的可能。（废话）&lt;/p&gt;
&lt;p&gt;Apple 官方介绍了3种应用场景：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;给 App 增加 Quick Actions：重按 App 图标，弹出一个快捷菜单&lt;/li&gt;
&lt;li&gt;Peek &amp;amp; Pop：轻按弹出 preview，再用力一点按 commit&lt;/li&gt;
&lt;li&gt;绘图类 App：例如按压的力道不同，线条的粗细则不同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文介绍了如何给 iOS App 添加基于 3D touch 的 Quick Actions，也即 Shortcut Items。&lt;/p&gt;
&lt;p&gt;其实 Apple 给的 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/samplecode/ApplicationShortcuts/Introduction/Intro.html#//apple_ref/doc/uid/TP40016545&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sample Project&lt;/a&gt; 非常翔实，读者可以直接下下来运行来看。&lt;/p&gt;
&lt;h3 id=&quot;没有屌屌的6s真机，我该怎么办呢？&quot;&gt;&lt;a href=&quot;#没有屌屌的6s真机，我该怎么办呢？&quot; class=&quot;headerlink&quot; title=&quot;没有屌屌的6s真机，我该怎么办呢？&quot;&gt;&lt;/a&gt;没有屌屌的6s真机，我该怎么办呢？&lt;/h3&gt;&lt;p&gt;这里有个对 iPhone 模拟器的小 tweak——&lt;a href=&quot;https://github.com/DeskConnect/SBShortcutMenuSimulator&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SBShortcutMenuSimulator&lt;/a&gt;，可以让 6s 模拟器展示出某个 App 的快捷菜单。&lt;/p&gt;
&lt;p&gt;但要注意的是，这个 tweak 并没有模拟 3D touch，而只能模拟展示某个 App 的 Quick Actions。&lt;/p&gt;
&lt;h3 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/iOS_quick_action_1.png&quot; width=&quot;30%&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;开始添加&quot;&gt;&lt;a href=&quot;#开始添加&quot; class=&quot;headerlink&quot; title=&quot;开始添加&quot;&gt;&lt;/a&gt;开始添加&lt;/h3&gt;&lt;p&gt;为 App 添加 Shortcut 有两种方式，一种是直接在 info.plist 里配置，另一种是通过代码添加。在代码里添加至少需要 App 运行过一次才会生效。&lt;/p&gt;
&lt;h3 id=&quot;在-info-plist-里配置：向系统注册-Static-类型的-Quick-Actions&quot;&gt;&lt;a href=&quot;#在-info-plist-里配置：向系统注册-Static-类型的-Quick-Actions&quot; class=&quot;headerlink&quot; title=&quot;在 info.plist 里配置：向系统注册 Static 类型的 Quick Actions&quot;&gt;&lt;/a&gt;在 info.plist 里配置：向系统注册 Static 类型的 Quick Actions&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/iOS_quick_action_2.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
&lt;p&gt;添加很简单。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UIApplicationShortcutItemType&lt;/code&gt;（必须） - 菜单项的ID，将来处理菜单的点击事件时，可以用来标识菜单项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIApplicationShortcutItemTitle&lt;/code&gt;（必须） &amp;amp; &lt;code&gt;UIApplicationShortcutItemSubtitle&lt;/code&gt;（可选） - 菜单项的标题&amp;amp;副标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIApplicationShortcutItemIconType&lt;/code&gt;(可选) &amp;amp; &lt;code&gt;UIApplicationShortcutItemIconFile&lt;/code&gt;（可选） - 系统预置了&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationShortcutIcon_Class/#//apple_ref/c/tdef/UIApplicationShortcutIconType&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;几种icon类型&lt;/a&gt;，当然，你也可以指定icon文件，见 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationShortcutIcon_Class/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UIApplicationShortcutIcon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIApplicationShortcutItemUserInfo&lt;/code&gt;（可选） - 用于传递信息，例如可以把App当前版本等信息传到代码中，即在代码中获取到 Shortcut Item 实例时，可以进一步获取这个字典，拿到里面的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;在代码里添加：运行时动态注册-Quick-Actions&quot;&gt;&lt;a href=&quot;#在代码里添加：运行时动态注册-Quick-Actions&quot; class=&quot;headerlink&quot; title=&quot;在代码里添加：运行时动态注册 Quick Actions&quot;&gt;&lt;/a&gt;在代码里添加：运行时动态注册 Quick Actions&lt;/h3&gt;&lt;p&gt;上图中的每个菜单项抽象到代码中是一个&lt;code&gt;UIApplicationShortcutItem&lt;/code&gt;类，&lt;code&gt;UIApplication&lt;/code&gt;类中新增了一个属性&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/#//apple_ref/occ/instp/UIApplication/shortcutItems&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;shortcutItems&lt;/code&gt;&lt;/a&gt;。我们需要在&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;中给这个属性赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define BUILD_TYPE(X) [NSString stringWithFormat:@&amp;quot;%@.%@&amp;quot;, [NSBundle mainBundle].bundleIdentifier, X]

if (!application.shortcutItems || application.shortcutItems.count == 0) {
    UIApplicationShortcutItem *item = [[UIMutableApplicationShortcutItem alloc] initWithType:BUILD_TYPE(@&amp;quot;Type3&amp;quot;)
                                                                              localizedTitle:@&amp;quot;GitHub&amp;quot;
                                                                           localizedSubtitle:@&amp;quot;liushuaikobe&amp;quot;
                                                                                        icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeLove]
                                                                                    userInfo:nil];
    application.shortcutItems = @[item];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要注意的是，在代码里直接设置&lt;code&gt;application.shortcutItems&lt;/code&gt;不会覆盖掉我们在 info.plist 里静态设置的菜单项，会 append 在 info.plist 中菜单项的后面。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h3&gt;&lt;p&gt;系统会优先显示静态的 Quick Actions，然后看看还有没有地方再决定是否展示动态的 Quick Actions。至于最多显示几个，官方文档也没给出明确的数字，只是用「system-defined limit」带过。不过经过测试，目前最多只能展示4个。&lt;/p&gt;
&lt;p&gt;此外，在runtime获取到的&lt;code&gt;shortcutItems&lt;/code&gt;，也只包括动态注册的 Quick Actions，静态注册的 Actions 是不包括在内的，因此在为这个数组赋值时，要注意加一个只注册一次的保护，先判断里面有没有值。&lt;/p&gt;
&lt;h3 id=&quot;Shortcut的事件处理&quot;&gt;&lt;a href=&quot;#Shortcut的事件处理&quot; class=&quot;headerlink&quot; title=&quot;Shortcut的事件处理&quot;&gt;&lt;/a&gt;Shortcut的事件处理&lt;/h3&gt;&lt;p&gt;&lt;code&gt;UIApplicationDelegate&lt;/code&gt;给我们提供了一个回调：&lt;code&gt;application:performActionForShortcutItem:completionHandler:&lt;/code&gt;，用于处理 App 的 Quick Actions。无论 App 的 Quick Action 启动了 App 还是重新让 App 回到前台，这个方法都会被调用。&lt;/p&gt;
&lt;p&gt;因此，我们可以把处理 Quick Actions 的逻辑放在这里：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)handleQuickActions:(UIApplicationShortcutItem *)item {

    void (^handle)(NSString *) = ^(NSString *type) {
        UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;Handle&amp;quot; message:type preferredStyle:UIAlertControllerStyleAlert];
        UIAlertAction *action = [UIAlertAction actionWithTitle:@&amp;quot;OK&amp;quot; style:UIAlertActionStyleDefault handler:nil];
        [alertController addAction:action];

        [self.window.rootViewController presentViewController:alertController animated:YES completion:nil];
    };

    if ([item.type isEqualToString:BUILD_TYPE(@&amp;quot;Type1&amp;quot;)]) {
        handle(item.type);
        return YES;
    } else if ([item.type isEqualToString:BUILD_TYPE(@&amp;quot;Type2&amp;quot;)]) {
        handle(item.type);
        return YES;
    } else if ([item.type isEqualToString:BUILD_TYPE(@&amp;quot;Type3&amp;quot;)]) {
        handle(item.type);
        return YES;
    }

    return NO;
}

- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler {
    BOOL hasHandled = [self handleQuickActions:shortcutItem];
    completionHandler(hasHandled); // 告诉系统Quick Actions有没有被妥善处理
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 Quick Actions 启动（不是从后台唤醒到前台）了 App 时，&lt;code&gt;UIApplicationDelegate&lt;/code&gt;中的方法&lt;code&gt;application:willFinishLaunchingWithOptions:&lt;/code&gt;和&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;还是会照常被调用，且这两个方法被调用了之后，&lt;code&gt;- application:performActionForShortcutItem:completionHandler:&lt;/code&gt;才会被调用。&lt;/p&gt;
&lt;p&gt;这种情况下，被点击的 Shortcut Item 会被放在这两个方法的参数 Options 字典中，作为&lt;code&gt;UIApplicationLaunchOptionsShortcutItemKey&lt;/code&gt;这个 key 的 value。因此，当你不得不在这两个方法中对 App 由 Quick Action 启动做一些特别的处理，那么官方的 Demo 推荐这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 首先在实现了 UIApplicationDelegate 的类中增加一个这样的实例变量，
// 用于保存当前触发 Quick Action 的 Shortcut Item 的引用

UIApplicationShortcutItem *_currentItem;

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    if (launchOptions &amp;amp;&amp;amp; launchOptions[UIApplicationLaunchOptionsShortcutItemKey]) {

        // 说明是由 Quick Action 启动的App
        // 获取到 Shortcut Item 的引用

        _currentItem = launchOptions[UIApplicationLaunchOptionsShortcutItemKey];

        // 如若返回NO，则系统不会调用 performActionForShortcutItem 方法
        // 因为我们会在 applicationDidBecomeActive 做出处理
        // 因此这里不希望 performActionForShortcutItem 先处理一下

        return NO;
    }

    return YES;
}

// 接着，在 applicationDidBecomeActive 时，做出处理

- (void)applicationDidBecomeActive:(UIApplication *)application {
    if (_currentItem) {
        [self handleShortcartItem:_currentItem];
        _currentItem = nil;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;官方的 Sample Project 用 Swift 编写，综合使用了 &lt;code&gt;guard&lt;/code&gt;，新式 enum 等多个 Swift 新特性，强烈建议读者前去阅读。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;3D Touch 的问世，给 iOS App 交互增加了更多的可能。（废话）&lt;/p&gt;
&lt;p&gt;Apple 官方介绍了3种应用场景：&lt;/p&gt;
    
    </summary>
    
      <category term="移动互联网开发" scheme="http://blog.liushuaiko.be/categories/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.liushuaiko.be/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一篇不算晚的Auto Layout入门教程</title>
    <link href="http://blog.liushuaiko.be/blog/2015/09/22/autolayout-introduction/"/>
    <id>http://blog.liushuaiko.be/blog/2015/09/22/autolayout-introduction/</id>
    <published>2015-09-22T02:54:20.000Z</published>
    <updated>2016-07-09T05:36:07.000Z</updated>
    
    <content type="html">&lt;p&gt;自打我混iOS圈以来，写UI就使用的是frame绝对布局。说是「绝对」，但在写的时候也已带着动态的思想了。比如，尽可能地用&lt;code&gt;autoResizingMask&lt;/code&gt;。但是对于那种mask不能用的场景，在写布局时就像在做小学几何题，很是复杂。&lt;/p&gt;
&lt;p&gt;在近期的项目中，尝试了Auto Layout，试着把自己的心得总结一下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Auto-Layout-简介&quot;&gt;&lt;a href=&quot;#Auto-Layout-简介&quot; class=&quot;headerlink&quot; title=&quot;Auto Layout 简介&quot;&gt;&lt;/a&gt;Auto Layout 简介&lt;/h3&gt;&lt;p&gt;网上介绍Auto Layout的文章很多，有一点大家很少提到。就Auto Layout本身来说，它并不是什么新鲜的技术。Auto Layou系统是&lt;a href=&quot;https://en.wikipedia.org/wiki/Cassowary_(software&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cassowary&lt;/a&gt;算法的Cocoa实现。Cassowary是一个在二十世纪九十年代被发明，解析&lt;strong&gt;线性&lt;/strong&gt;等式、不等式约束的一个算法。&lt;/p&gt;
&lt;p&gt;开发者提供一系列的&lt;strong&gt;布局规则&lt;/strong&gt;给Cocoa Auto Layout系统，它基于Cassowary算法，把规则转换成了View(s)的frame，完成了布局。这个所谓的「布局规则」，就是Auto Layout里的「约束」，Constraint。&lt;/p&gt;
&lt;p&gt;前面说到，Cassowary算法解析的线性等式、不等式，因此，我们提供给Auto Layout的约束是线性的约束。可以简单把线性约束理解为用一次方程来描述的约束。&lt;/p&gt;
&lt;p&gt;一次方程，它的基本形式（以等式为例）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;y = kx + b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自然地，在Auto Layout中，一个约束该长什么样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;view1的某个属性 = k * view2的某个属性 + b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上面所示，一个约束描述了两个属性之间的关系，涉及到了7个量（view1、属性1、关系、view2、属性2、k、b）。&lt;/p&gt;
&lt;p&gt;我们就是把这种形式的一条条的规则提供给Auto Layout，它综合了许许多多这样的规则，来完成布局。&lt;/p&gt;
&lt;p&gt;「Hey，小奥，这个View要靠左显示，离它爹10像素吧！」&lt;br&gt;「小奥，这个Label跟它上面的按钮垂直居中！」&lt;/p&gt;
&lt;p&gt;怎么样？反正给我的感受是，frame布局是我们替机器思考，而Auto Layout，是为我们自己思考。&lt;/p&gt;
&lt;h3 id=&quot;Constraint-in-Code&quot;&gt;&lt;a href=&quot;#Constraint-in-Code&quot; class=&quot;headerlink&quot; title=&quot;Constraint in Code&quot;&gt;&lt;/a&gt;Constraint in Code&lt;/h3&gt;&lt;p&gt;上文我们介绍了在逻辑中该怎么去表示一个「约束」。那落实到代码中，该怎么表示呢？&lt;/p&gt;
&lt;p&gt;苹果给我们提供了这样一个类，用作代码中一个约束的抽象——&lt;code&gt;NSLayoutConstraint&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它有一个很长的构造方法，返回一个约束实例，这个方法的参数就是上面提到的7个量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSLayoutConstraint *c = [NSLayoutConstraint constraintWithItem:view1 attribute:attr1
                                                     relatedBy:relation
                                                        toItem:view2 attribute:attr2
                                                    multiplier:k constant:b];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这个方法，我们构造一个又一个的&lt;code&gt;NSLayoutConstraint&lt;/code&gt;实例，通过把这些实例add给合适的View的方式提供给Auto Layout System，就完成了代码层面的添加约束的过程。&lt;/p&gt;
&lt;h3 id=&quot;Before-starting&quot;&gt;&lt;a href=&quot;#Before-starting&quot; class=&quot;headerlink&quot; title=&quot;Before starting&quot;&gt;&lt;/a&gt;Before starting&lt;/h3&gt;&lt;p&gt;在你迫不及待的想上手之前，有两点务必记住。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码上忘掉&lt;code&gt;frame&lt;/code&gt;和&lt;code&gt;autoresizingMask&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;父View当前的大小是不可靠的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于第一点，由于Auto Layout System已经接管了frame的设置，如果你再来掺一脚，会有很多诡异的问题。注意我说的是在代码上忘掉&lt;code&gt;frame&lt;/code&gt;，在思考某个特定View的约束时，还是要想到它的frame的概念的。回想我们的frame布局时代，一个frame：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{x, y, width, height}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有四个量，也就是说至少需要四个量才能确定一个View的布局，逻辑上想想确实是那么回事。那我在我们添加某个View的约束时，也至少需要四个约束，才能确定一个View的布局。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;水平方向：我在哪？我多宽？
竖直方向：我在哪？我多高？
　　　　　　　　　　　　　---- 一个View的独白
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;忘掉&lt;code&gt;autoresizingMask&lt;/code&gt;同理。我们甚至&lt;strong&gt;必须要&lt;/strong&gt;显式地设置&lt;code&gt;translatesAutoresizingMaskIntoConstraints&lt;/code&gt;来保证约束的正确解析。当你在Auto Layout里摸爬滚打，痛不欲生却无论如何也没有正确优雅的布局映入你眼帘的时候，一定要记得回过头来看看，是不是忘记把相关View的这个属性设置为&lt;code&gt;NO&lt;/code&gt;了！&lt;/p&gt;
&lt;p&gt;对于第二点，这是为了强迫你用动态的思维去思考该怎么描述约束。走出根据父View的bounds来设置子View的frame的时代吧，enjoy Auto Layout！&lt;/p&gt;
&lt;h3 id=&quot;Add-Constraints&quot;&gt;&lt;a href=&quot;#Add-Constraints&quot; class=&quot;headerlink&quot; title=&quot;Add Constraints&quot;&gt;&lt;/a&gt;Add Constraints&lt;/h3&gt;&lt;p&gt;接下来我们就开始计划着给View添加约束了。假设给了你一块地（一个View），你要给它的子View们添加约束，用Auto Layout进行布局，大致的思路如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给这些Views大致分分组。当子View很多时，没必要全把他们当儿子。合理地用一些Container View，把儿子变成孙子，达到简化约束的目的。&lt;/li&gt;
&lt;li&gt;确定儿子们的布局依赖等级关系。举个例子，要想确定儿子A的位置，首先我得知道儿子B的位置。换句话说，只要儿子B的位置确定了，那么儿子A的位置就能确定。&lt;/li&gt;
&lt;li&gt;找出那些只依赖父亲的儿子，也即依赖关系最顶层的儿子（一定存在），先添加它们的约束。&lt;/li&gt;
&lt;li&gt;根据依赖关系层级，逐级添加约束&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h3&gt;&lt;p&gt;假设我们要实现一个TableView，它的每个Cell中有个ImageView，显示一张图。大致效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/autolayout1.png&quot; width=&quot;40%&quot;&gt;&lt;/p&gt;
&lt;p&gt;按着上面的思路，因为这个父亲（TableView Cell的contentView，注意使用Auto Layout布局TableView Cell一定要把儿子加在cotnentView上，不然在iOS 7、8上会有很诡异的问题）只有一个儿子，布局依赖关系也就很清楚了，开始构思约束。&lt;/p&gt;
&lt;p&gt;Wait，在添加约束前，要先告知Auto Layout System ImageView和self.contentView的父子关系：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_imageView = [[UIImageView alloc] init];
_imageView.backgroundColor = [UIColor orangeColor];
_imageView.translatesAutoresizingMaskIntoConstraints = NO; // Don&amp;apos;t forget !!
[self.contentView addSubview:_imageView];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OK，首先，这个ImageView的上、左、下距离它爹各20，约束如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSLayoutConstraint *c1 = [NSLayoutConstraint constraintWithItem:_imageView attribute:NSLayoutAttributeLeft
                                                      relatedBy:NSLayoutRelationEqual
                                                         toItem:self.contentView attribute:NSLayoutAttributeLeft
                                                     multiplier:1 constant:20];

NSLayoutConstraint *c2 = [NSLayoutConstraint constraintWithItem:_imageView attribute:NSLayoutAttributeTop
                                                      relatedBy:NSLayoutRelationEqual
                                                         toItem:self.contentView attribute:NSLayoutAttributeTop
                                                     multiplier:1 constant:20];

NSLayoutConstraint *c3 = [NSLayoutConstraint constraintWithItem:_imageView attribute:NSLayoutAttributeBottom
                                                      relatedBy:NSLayoutRelationEqual
                                                         toItem:self.contentView attribute:NSLayoutAttributeBottom
                                                     multiplier:1 constant:-20];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来分析一下。垂直方向，当&lt;code&gt;self.contentView&lt;/code&gt;的高度确定后，由于我们指定了&lt;code&gt;_imageView&lt;/code&gt;的上下边距，则y和height都能被确定；水平方向上，我们指定了左边距，能确定x，但是width不能确定，因此我们还需要一个约束：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSLayoutConstraint *c4 = [NSLayoutConstraint constraintWithItem:_imageView attribute:NSLayoutAttributeWidth
                                                      relatedBy:NSLayoutRelationEqual
                                                         toItem:_imageView attribute:NSLayoutAttributeHeight
                                                     multiplier:1 constant:0];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;c4&lt;/code&gt;告诉了Auto Layout System，&lt;code&gt;_imageView&lt;/code&gt;的长和宽相等。这样，它的约束就齐活了。&lt;/p&gt;
&lt;p&gt;接着，这四个约束要给谁加。注意，每个约束要加载这个约束涉及到的两个View的&lt;strong&gt;最小父View&lt;/strong&gt;上，Forgiveness，这是我自己提出的概念。注意到&lt;code&gt;c1&lt;/code&gt;，&lt;code&gt;c2&lt;/code&gt;，&lt;code&gt;c3&lt;/code&gt;涉及到的两个View是&lt;code&gt;self.contentView&lt;/code&gt;和&lt;code&gt;_imageView&lt;/code&gt;，其中&lt;code&gt;_imageView&lt;/code&gt;是&lt;code&gt;self.contentView&lt;/code&gt;的子View，因此约束就需要加给&lt;code&gt;self.contentView&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self.contentView addConstraints:@[c1, c2, c3]];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;c4&lt;/code&gt;涉及到的两个View是&lt;code&gt;_imageView&lt;/code&gt;本身，约束加给它自己。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[_imageView addConstraint:c4];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行起来，结果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7nj23c.com1.z0.glb.clouddn.com/autolayout2.png&quot; width=&quot;30%&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Visual-Format-Language&quot;&gt;&lt;a href=&quot;#Visual-Format-Language&quot; class=&quot;headerlink&quot; title=&quot;Visual Format Language&quot;&gt;&lt;/a&gt;Visual Format Language&lt;/h3&gt;&lt;p&gt;继续上面的例子。或许你会抱怨，每个View都需要搞这么一发，得写多少代码啊！&lt;/p&gt;
&lt;p&gt;苹果贴心地给我们搞了一套形象地表示约束的方法——Visual Format Language（VFL）。&lt;/p&gt;
&lt;p&gt;上面的&lt;code&gt;c1&lt;/code&gt;，&lt;code&gt;c2&lt;/code&gt;，&lt;code&gt;c3&lt;/code&gt;可以表示成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CGFloat leftMargin = 20;

NSArray *cs = [NSLayoutConstraint constraintsWithVisualFormat:@&amp;quot;H:|-(leftMargin)-[_imageView]&amp;quot;
                                                      options:0 metrics:@{@&amp;quot;leftMargin&amp;quot;: @(leftMargin)}
                                                        views:NSDictionaryOfVariableBindings(_imageView)];
NSArray *cs1 = [NSLayoutConstraint constraintsWithVisualFormat:@&amp;quot;V:|-20-[_imageView]-20-|&amp;quot;
                                                      options:0 metrics:nil
                                                        views:NSDictionaryOfVariableBindings(_imageView)];

[self.contentView addConstraints:cs];
[self.contentView addConstraints:cs1];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要把VFL说完，得新写一篇文章了啊，篇幅限制，就不展开叙述了，具体请看：&lt;a href=&quot;https://developer.apple.com/library/prerelease/tvos/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;后续&quot;&gt;&lt;a href=&quot;#后续&quot; class=&quot;headerlink&quot; title=&quot;后续&quot;&gt;&lt;/a&gt;后续&lt;/h3&gt;&lt;p&gt;如果认真看到这，那么相信你是真的入门了。Auto Layout的东西还有很多，值得你去花时间继续深入调研。&lt;/p&gt;
&lt;p&gt;比如，每个约束还有优先级之分。当Auto Layout System发现你给它的约束有冲突，它会根据有冲突的约束的优先级进行仲裁。&lt;/p&gt;
&lt;p&gt;还有一些其它的东西是入门之后需要细细体会的，最好自己写一些Demo。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/#frame-vs-alignment-rect&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Frame vs. Alignment Rect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/#intrinsic-content-size&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intrinsic Content Size 以及 Compression Resistance 和 Content Hugging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/#animation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Animation with Auto Layout&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt; &lt;em&gt;参考文献&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stacks.11craft.com/cassowary-cocoa-autolayout-and-enaml-constraints.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stacks.11craft.com/cassowary-cocoa-autolayout-and-enaml-constraints.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.informit.com/articles/article.aspx?p=2151265&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.informit.com/articles/article.aspx?p=2151265&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sourceforge.net/p/cassowary/wiki/Home/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sourceforge.net/p/cassowary/wiki/Home/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/16281229/1108052&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/a/16281229/1108052&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/tvos/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/library/prerelease/tvos/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;自打我混iOS圈以来，写UI就使用的是frame绝对布局。说是「绝对」，但在写的时候也已带着动态的思想了。比如，尽可能地用&lt;code&gt;autoResizingMask&lt;/code&gt;。但是对于那种mask不能用的场景，在写布局时就像在做小学几何题，很是复杂。&lt;/p&gt;
&lt;p&gt;在近期的项目中，尝试了Auto Layout，试着把自己的心得总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="移动互联网开发" scheme="http://blog.liushuaiko.be/categories/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.liushuaiko.be/tags/iOS/"/>
    
      <category term="AutoLayout" scheme="http://blog.liushuaiko.be/tags/AutoLayout/"/>
    
  </entry>
  
  <entry>
    <title>使用Core Text实现支持iOS 6的图文混排</title>
    <link href="http://blog.liushuaiko.be/blog/2015/05/23/CoreText-Introduction/"/>
    <id>http://blog.liushuaiko.be/blog/2015/05/23/CoreText-Introduction/</id>
    <published>2015-05-23T10:14:21.000Z</published>
    <updated>2016-07-09T05:35:54.000Z</updated>
    
    <content type="html">&lt;p&gt;为了让图文混排支持iOS 6，不得不暂时放弃学习TextKit，不过正好也借着这个机会了解了文字排版的一些基本知识，以及如何直接使用底层的Core Text API，来进行图文混排。正所谓出来混，总是要还的，学一些这方面的知识，对学习TextKit也是很有帮助的！&lt;/p&gt;
&lt;p&gt;本文将介绍使用Core Text的API，结合Core Graphics来实现支持iOS 6的图文混排的基本思想及方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;效果图预览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/CoreTextDemo.png&quot; width=&quot;30%&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;知识储备&quot;&gt;&lt;a href=&quot;#知识储备&quot; class=&quot;headerlink&quot; title=&quot;知识储备&quot;&gt;&lt;/a&gt;知识储备&lt;/h3&gt;&lt;p&gt;Core Text是进行文字排版的工具，为了更称手地使用它，了解一些文字排版的基础知识很有必要。为了后续理解方便，强烈建议先阅读&lt;a href=&quot;http://geeklu.com/2013/03/core-text/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇很好的文章&lt;/a&gt;，我就不拾人牙慧了。&lt;/p&gt;
&lt;p&gt;但是祭出这两幅幅神图还是很有必要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/glyphterms.png&quot; width=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/glyphmetrics.png&quot; width=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;p&gt;基于上图，有几个点还是需要强调一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Baseline，基线。想想你是如何在四线三格纸上写英文字母的，基线就相当于第三条线&lt;/li&gt;
&lt;li&gt;Line Origin，行原点。把一橫行文字的基线看成是一条线段，线段的起点就是这行的Line Origin&lt;/li&gt;
&lt;li&gt;Ascent，上高。一行文字，共享一条基线，最高的字形到基线的高就是上高，是一个正值&lt;/li&gt;
&lt;li&gt;Descent，下高。同Ascent，最深的字形到基线的高就是下高，是一个负值&lt;/li&gt;
&lt;li&gt;leading，行距。行与行之间的距离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么再回过头来看Core Text中一些基本的概念以及对应的类。&lt;/p&gt;
&lt;p&gt;进行文字的绘制，总得有个地方吧！也即总得告诉CT在那块把字给画出来？这个所谓的「地方」，就是CTFrame。&lt;br&gt;在使用的过程中，我们通常是用一个AttributedString来初始化一个CTFrame的工厂&lt;code&gt;CTFramesetter&lt;/code&gt;，然后用这个工厂结合一个&lt;code&gt;CGPath&lt;/code&gt;，来得到一个CTFrame。&lt;/p&gt;
&lt;p&gt;CT在CTFrame上绘制文字的时候，不会超出这个Frame，一行显示不下，新起一行，「行」在CT中的对象模型就是CTLine。&lt;br&gt;对于每一行，具有相同属性（对，就是你给AttributedString添加的属性）的紧挨着的字形集合体，被称为一个CTRun。&lt;/p&gt;
&lt;p&gt;一个Run在渲染的时候，如果设置了CTRunDelegate，那么便会向它的Delegate询问一些信息，包括这个Run的Ascent、Descent，以及宽度等等。注意CT是一个C级别的库，CTRunDelegate也是通过C语言中函数指针来完成设置的，详见下面的代码。&lt;/p&gt;
&lt;p&gt;有关Core Text的几个核心概念可以参考下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/coretextterms.png&quot; alt=&quot;coretextterms.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h3&gt;&lt;p&gt;我们使用Core Text来进行排版（typeset）和文字的绘制，并利用其获取图片位置，使用Core Graphics进行图片的绘制。&lt;/p&gt;
&lt;p&gt;这个过程可以分成两步。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用CT进行文字的排版和绘制，为该显示图片的地方留出位置&lt;/li&gt;
&lt;li&gt;遍历每一行，按行画出这行的图片&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Go-Go-Go&quot;&gt;&lt;a href=&quot;#Go-Go-Go&quot; class=&quot;headerlink&quot; title=&quot;Go Go Go&quot;&gt;&lt;/a&gt;Go Go Go&lt;/h3&gt;&lt;p&gt;在对基本的概念以及思想了解各大概后，便可以动手来实现了！&lt;/p&gt;
&lt;p&gt;且慢，为了测试结果更加直观，我们先编写一些工具方法，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)drawBorder:(CGRect)rect inContext:(CGContextRef)context {
    CGPathRef rectBorderPath = CGPathCreateWithRect(rect, NULL);
    [[UIColor redColor] setStroke];
    CGContextAddPath(context, rectBorderPath);
    CGContextDrawPath(context, kCGPathStroke);
    CFRelease(rectBorderPath);
}

- (void)drawPoint:(CGPoint)point inContext:(CGContextRef)context {
    CGContextFillRect(context, CGRectMake(point.x, point.y, 2, 2));
}

// 先转换坐标系再画点
- (void)drawPoint:(CGPoint)point inContext:(CGContextRef)context inRect:(CGRect)rect {
    UIView *view = [[UIView alloc] initWithFrame:rect];
    view.backgroundColor = [UIColor yellowColor];
    [self addSubview:view];
    CGPoint pointInSelf = [self convertPoint:point fromView:view];
    [view removeFromSuperview];
    [self drawPoint:pointInSelf inContext:context];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;终于可以上关键代码了，代码中注释已经很翔实了！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)drawRect:(CGRect)rect {
    [super drawRect:rect];

    CGContextRef context = UIGraphicsGetCurrentContext();

    // 翻转坐标系
    CGContextSetTextMatrix(context, CGAffineTransformIdentity);
    CGContextTranslateCTM(context, 0, CGRectGetHeight(self.bounds));
    CGContextScaleCTM(context, 1.0, -1.0);

    // 可以在翻转坐标系之前也画个红绿色块来对比坐标系Y轴翻转的效果
    CGContextSetRGBFillColor (context, 1, 0, 0, 1);
    CGContextFillRect (context, CGRectMake (100, 100, 100, 100 ));
    CGContextSetRGBFillColor (context, 0, 1, 0, .5);
    CGContextFillRect (context, CGRectMake (150, 205, 100, 100));

    // 准备CGPath，用于CTFrame的构造
    CGMutablePathRef path = CGPathCreateMutable();
    CGFloat frameOffsetX = 20.0f;
    CGFloat frameOffsetY = 20.0f;
    CGRect textFrame = CGRectInset(self.bounds, frameOffsetX, frameOffsetY);
    CGPathAddRect(path, NULL, textFrame);

    [self drawBorder:textFrame inContext:context];

    // 装文字的AttributedString
    NSMutableAttributedString *str = [[NSMutableAttributedString alloc] initWithString:@&amp;quot;Our destiny offers not the cup of despair, but the chalice of opportunity. So let us seize it, not in fear, but in gladness.——R.M. Nixon&amp;quot; attributes:@{NSForegroundColorAttributeName: [UIColor greenColor], NSFontAttributeName: [UIFont systemFontOfSize:22]}];

    // 构造CTRunDelegate，用以给占着图片位置的空字符的CTRun作为Delegate，提供这些Run的宽、上下高等
    NSDictionary *attrs = @{@&amp;quot;key&amp;quot;: @&amp;quot;vars.me&amp;quot;};
    CTRunDelegateCallbacks imageCallbacks;
    imageCallbacks.version = kCTRunDelegateVersion1;
    imageCallbacks.dealloc = deallocCallback;
    imageCallbacks.getDescent = descentCallback;
    imageCallbacks.getAscent = ascentCallback;
    imageCallbacks.getWidth = widthCallback;
    // http://stackoverflow.com/a/12919404/1108052
    CTRunDelegateRef runDelegate = CTRunDelegateCreate(&amp;amp;imageCallbacks, (void *)CFBridgingRetain(attrs)); // 第二个参数就是传给callBack函数的void *类型的参数

    // 随机构造几个装有图片占位符的AttributedString，插入到上面装文字的AttributedString中
    unichar space = 0xFFFC; // 图片占位符，为什么用0xFFFC下述详情
    NSString *spaceStr = [NSString stringWithCharacters:&amp;amp;space length:1];
    // 装有图片占位符的AttributedString，注意，其属性中有一个@&amp;quot;imageName&amp;quot;属性，这是我们区别一个Run是否是图片Run的标识，见下面遍历每行Run部分
    NSMutableAttributedString *imageStr = [[NSMutableAttributedString alloc] initWithString:spaceStr attributes:@{(NSString *)kCTRunDelegateAttributeName: (__bridge id)runDelegate, @&amp;quot;imageName&amp;quot;: @&amp;quot;001.png&amp;quot;}];
    [str insertAttributedString:imageStr atIndex:5];
    [str insertAttributedString:imageStr atIndex:55];
    [str insertAttributedString:imageStr atIndex:75];
    [str insertAttributedString:imageStr atIndex:105];
    [str insertAttributedString:imageStr atIndex:135];

    // 构造CTFrame
    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)str);
    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, str.length), path, NULL);

    // 得到Frame中的每一行，装在一个CFArray里
    CFArrayRef lines = CTFrameGetLines(frame);

    // 得到每一行的Line Origin（见上述知识储备部分），用以计算每一行的图片位置，注意，得到的点是以CTFrame为坐标系的坐标
    CGPoint lineOrigins[CFArrayGetCount(lines)];
    CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), lineOrigins);

    // 下面遍历Frame中的每一行，逐行绘制图片
    for (CFIndex i = 0; i &amp;lt; CFArrayGetCount(lines); ++i) {
        CTLineRef line = CFArrayGetValueAtIndex(lines, i);

        [self drawPoint:lineOrigins[i] inContext:context inRect:textFrame];

        // 得到这行中的所有CTRun，状态一个CFArray里
        CFArrayRef runs = CTLineGetGlyphRuns(line);

        // 遍历这行所有Run
        for (CFIndex j = 0; j &amp;lt; CFArrayGetCount(runs); ++j) {
            CTRunRef run = CFArrayGetValueAtIndex(runs, j);
            NSDictionary *attrs = (NSDictionary *)CTRunGetAttributes(run);

            // 如果某个Run的@&amp;quot;imageName&amp;quot;属性不为空，则说明这个Run是图片占位符，开始计算这个Run的位置，用CG画图
            NSString *imageName = attrs[@&amp;quot;imageName&amp;quot;];
            if (imageName) {
                CGPoint lineOrigin = lineOrigins[i];

                CGRect imageRunBounds; // 注意：得到的imageRun的bounds，也是在CTFrame坐标系中
                CGFloat imageRunAsent, imageRunDecent;
                imageRunBounds.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;amp;imageRunAsent, &amp;amp;imageRunDecent, NULL);
                imageRunBounds.size.height = imageRunAsent + imageRunDecent;
                imageRunBounds.origin.x = lineOrigin.x + CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);
                imageRunBounds.origin.y = lineOrigin.y;

                // 开始画图
                UIImage *image = [UIImage imageNamed:imageName];
                if (image) {
                    // 注意：画图时由于是在当前View的Context中，因此我们要根据CTFrame坐标系中的imageRunBounds，转换成在View坐标系的imageDrawRect
                    CGRect imageDrawRect;
                    imageDrawRect.origin.x = imageRunBounds.origin.x + lineOrigin.x + frameOffsetX;
                    imageDrawRect.origin.y = imageRunBounds.origin.y +  frameOffsetY;
                    imageDrawRect.size = imageRunBounds.size;

                    // 用CG画图
                    CGContextDrawImage(context, imageDrawRect, image.CGImage);

                    [self drawBorder:imageDrawRect inContext:context];
                }
            }
        }
    }

    CTFrameDraw(frame, context);

    CFRelease(runDelegate);
    CFRelease(frame);
    CFRelease(path);
    CFRelease(framesetter);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CTRunDelegate的回调函数代码如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#pragma mark - CTRunDelegate

void deallocCallback(void* ref) {
    CFBridgingRelease(ref);
}

CGFloat ascentCallback(void *ref) {

    NSDictionary *attr = (__bridge NSDictionary *)ref;
    NSLog(@&amp;quot;%@&amp;quot;, attr[@&amp;quot;key&amp;quot;]);

    return 32;
}

CGFloat descentCallback(void* ref) {
    return 0;
}

CGFloat widthCallback(void* ref) {
    return 32;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对代码的理解可以结合下图（使用Sketch画的，真是个好工具）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/CoreTextCode.png&quot; alt=&quot;CoreTextCode.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;此外，关于上面的代码有几点补充，一是坐标系Y轴翻转的问题，前面推荐过的那篇很好的文章已经说的很详细了，这里就不做赘述了；二是为什么占位符要选择0xFFFC，有两方面原因，一个是&lt;code&gt;kCTRunDelegateAttributeName&lt;/code&gt;的官方文档推荐使用这个值，二是经过我自己的测试(iPhone 5)，使用这个值有如下优势，自动把一个imageRun当成一个单词处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/CTCompare.png&quot; width=&quot;50%&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://geeklu.com/2013/03/core-text/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core Text 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.raywenderlich.com/4147/core-text-tutorial-for-ios-making-a-magazine-app&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core Text Tutorial for iOS: Making a Magazine App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.devtang.com/blog/2013/10/21/the-tech-detail-of-ape-client-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;猿题库iOS客户端的技术细节（三）：基于CoreText的排版引擎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/Carbon/Reference/CoreText_Framework_Ref/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core Text Reference Collection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;为了让图文混排支持iOS 6，不得不暂时放弃学习TextKit，不过正好也借着这个机会了解了文字排版的一些基本知识，以及如何直接使用底层的Core Text API，来进行图文混排。正所谓出来混，总是要还的，学一些这方面的知识，对学习TextKit也是很有帮助的！&lt;/p&gt;
&lt;p&gt;本文将介绍使用Core Text的API，结合Core Graphics来实现支持iOS 6的图文混排的基本思想及方法。&lt;/p&gt;
    
    </summary>
    
      <category term="移动互联网开发" scheme="http://blog.liushuaiko.be/categories/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.liushuaiko.be/tags/iOS/"/>
    
      <category term="CoreText" scheme="http://blog.liushuaiko.be/tags/CoreText/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView的数据预加载及图片加载逻辑的优化</title>
    <link href="http://blog.liushuaiko.be/blog/2015/04/26/UICollectionView-Optimizing/"/>
    <id>http://blog.liushuaiko.be/blog/2015/04/26/UICollectionView-Optimizing/</id>
    <published>2015-04-26T09:26:34.000Z</published>
    <updated>2016-07-09T05:35:41.000Z</updated>
    
    <content type="html">&lt;p&gt;当App中使用了&lt;code&gt;UICollectionView&lt;/code&gt;以瀑布流的形式来呈现数据时，站在用户的角度，用户在自上至下一页一页浏览这些内容的过程中，当用户感到滑动很流畅自然，每页内容从无到有需要用户等待的时间很短甚至几乎感觉不到，那么&lt;code&gt;UICollectionView&lt;/code&gt;才会带给用户一个很好的体验。本文介绍了为了达到这两个目的所作出的一些客户端的优化。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;数据的预加载&quot;&gt;&lt;a href=&quot;#数据的预加载&quot; class=&quot;headerlink&quot; title=&quot;数据的预加载&quot;&gt;&lt;/a&gt;数据的预加载&lt;/h3&gt;&lt;p&gt;数据预加载的目的是不必等到用户某一时刻浏览到CollectionView的末尾了，也即本地已经没有更多数据展示了才去发请求拿下一页数据，而是有一个预判，用户就快要看完本地的数据了，可以向Server要下一页数据了！&lt;/p&gt;
&lt;p&gt;为了实现预加载，最开始的方案是在UI层面的预判。根据&lt;code&gt;UICollectionView&lt;/code&gt;的基类是&lt;code&gt;UIScrollView&lt;/code&gt;，大致思路是对于沿竖直方向滚动的CollectionView，考察它的&lt;code&gt;contentOffset.y&lt;/code&gt;和&lt;code&gt;conetntSize.height&lt;/code&gt;，结合CollectionView的&lt;code&gt;frame.size.height&lt;/code&gt;，可以计算CollectionView全部内容底下还有多高没展示出来，如果高度小于我们预先设定的阈值（用户快滑到底了），那么就触发加载下一页的请求。&lt;/p&gt;
&lt;p&gt;这样做似乎没什么问题，但是仔细想想，其实并不优雅。一方面，一旦有UI调整的需求，CollectionView每行的高度有调整时，我们也要去调整阈值，来决定是否去请求下一页数据；另一方面，App中不同场景下的CollectionView每行高度不同，需要根据不同场景去Tuning，找出合适的阈值。&lt;/p&gt;
&lt;p&gt;后来很自然想到在逻辑上进行预判，也就是我们现在使用的方案。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UICollectionView&lt;/code&gt;每个Cell都需要一个数据模型对象（Data Transfer Object，下称DTO）来支持它的显示，通常客户端拿到的服务端返回的数据后，做一系列的解析，得到一个一个DTO，用以支持CollectionView的展示。到代码层面DTO们被保存在一个数组里，任意时刻在正确的状态下&lt;code&gt;UICollectionView&lt;/code&gt;的总Cell数量应该跟当前本地DTO的个数相等，Cell跟DTO是一一对应的关系，&lt;strong&gt;数据的预加载本质上就是DTO的预加载&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;用户在滚动&lt;code&gt;UICollectionView&lt;/code&gt;时，当&lt;code&gt;UICollectionView&lt;/code&gt;根据预定的配置觉得它该展示某行某列的Cell时，会向它的DataSource[2]发送&lt;code&gt;collectionView:cellForItemAtIndexPath:&lt;/code&gt;消息[3]，询问那行那列该展示什么，这个方法返回一个Cell对象，&lt;code&gt;UICollectionView&lt;/code&gt;拿到这个Cell后就把它展示在相应位置。通常这个方法中要做的重要事情就是去上文提到的保存DTO的数组中根据Cell的行列索引找到这个Cell对应的DTO，根据DTO对Cell配置一番，返回给&lt;code&gt;UICollectionView&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 顺着这个思路，在这个方法中可以知道当前&lt;code&gt;UICollectionView&lt;/code&gt;需要展示的Cell的索引，由于Cell跟DTO是一一对应的关系，那我们也知道了当前需要的DTO在总数据模型对象中的索引，当剩下的数据模型对象不够支持一页的显示时，就去请求下一页。&lt;/p&gt;
&lt;p&gt;表达的可能有点抽象，假设请求一次Server返回20个DTO，过程可以更形象化一点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- CollectionView: 数据源数据源，用户滑到第181个Cell要露出来了，快给我！
- DataSource: 好的，我首先要去拿第181个Cell对应的DTO，根据这个配置好一个Cell给你去展示！
等等，你都已经展示到第181个Cell了啊！我发现DTO目前本地总共只有200个，200 - 181 = 19 &amp;lt; 20不够支持你展示下一页所需要的20个Cell了，我先发起一个异步请求，去拿新一页的DTO！
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键代码，很简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSUInteger countOfDataModel = dataModel.count; // 目前本地有的DTO数量
NSUInteger currentRequestIndex = indexPath.row; // 当前需要的Cell索引，也即当前需要的数据模型索引

if (countOfDataModel - currentRequestIndex &amp;lt; 19) {
    [self fetchNextPageAsync];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要注意的问题是要做好防止重复发送请求的保护工作。&lt;/p&gt;
&lt;h3 id=&quot;图片加载逻辑优化&quot;&gt;&lt;a href=&quot;#图片加载逻辑优化&quot; class=&quot;headerlink&quot; title=&quot;图片加载逻辑优化&quot;&gt;&lt;/a&gt;图片加载逻辑优化&lt;/h3&gt;&lt;p&gt;当&lt;code&gt;UICollectionView&lt;/code&gt;的每个Cell都需要展示一个（或多个）图片时，在上文提到的根据DTO配置Cell过程中，会根据DTO中指定的图片的URL，发送一个异步的图片请求，等到图片请求完毕了，再把图片展示到对应的Cell上（当然，可以把这一切交给&lt;code&gt;SDWebImage&lt;/code&gt;: ）。&lt;/p&gt;
&lt;p&gt;或许你会问，加载图片已经是异步了啊，我还要优化什么？不，这远远不够。在实际的测试中，这种朴素的做法依然会带来明显的滑动过程的卡顿。使用Instruments进行profile发现，在滑动过程中始终会丢那么15帧左右，不能忍！&lt;/p&gt;
&lt;p&gt;再回到&lt;code&gt;UICollectionView&lt;/code&gt;继承自&lt;code&gt;UIScrollView&lt;/code&gt;上来。通过&lt;code&gt;UIScrollView&lt;/code&gt;的Delegate，我们能感知到滑动过程中CollectionView的各种关键状态，包括用户的手是否正在拖拽，以及CollectionView是否正在滑动、减速等等，这就是我们优化的秘密武器！&lt;/p&gt;
&lt;p&gt;那么，本着不该做的事情不要做，或者等到不得不做的时候再做的原则，让我们分析用户在滑动CollectionView的过程中有哪些地方可以细抠。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户在滑动（拖拽）CollectionView时（手与屏幕正在接触），很有可能是用户在认真逐个浏览每个Cell，要去加载当前可见Cell的图片&lt;/li&gt;
&lt;li&gt;用户滑动CollectionView结束后，手离开了屏幕，并引发了CollectionView减速时，&lt;strong&gt;预判&lt;/strong&gt;CollectionView减速结束后静止时的状态，对于那些将来静止时用户可见的Cell，提前去加载它们的图片；对于那些只是“昙花一现”的Cell，即它们只是在减速的过程中出现那么一刹那，就被“顶”上去了，只加载这些Cell中图片在本地有缓存的图片（从内存中加载，不值得去发网络请求，即使是异步的也不值得）&lt;/li&gt;
&lt;li&gt;减速结束后，CollectionView处于静止状态，加载当前全部可见Cell的图片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OK，那么来看我们怎么实现它。&lt;/p&gt;
&lt;p&gt;对于CollectionView的每个Cell，我们给它添加一个异步加载图片的方法&lt;code&gt;loadImage&lt;/code&gt;。直接上关键代码，看了便知。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// CollectionView将来静止时可见的区域，同时也是标识CollectionView当前是正在被用户拖拽还是已经被拖拽完毕并正在减速
@property (nonatomic, strong) CGRect *targetRect;

#pragma mark - UICollectionView DataSource

- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath {
    // ....
    [self loadImageForCell:cell atIndexPath:indexPath];
    // ....
}

#pragma mark - UIScrollView Delegate

- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {
    self.targetRect = nil;
    [self loadImageForVisibleCells];
}

- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset {
    self.targetRect = CGRectMake(targetContentOffset-&amp;gt;x, targetContentOffset-&amp;gt;y, scrollView.frame.size.width, scrollView.frame.size.height);
}

- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {
    self.targetRect = nil;
    [self loadImageForVisibleCells];
}

#pragma mark - Decide to Load Image For Cells

- (void)loadImageForCell:(AESmartCollectionFlowViewCell *)cell
        atIndexPath:(NSIndexPath *)indexPath {
    // Cell的targetURLString是指派给Cell的新的图片URL，在根据Cell的DTO配置Cell时为其赋值
    if (!cell.targetURLString) {
        return;
    }
    // Cell的imageURLString是Cell的当前正在显示的图片URL
    if (![cell.targetURLString isEqualToString:cell.imageURLString] || cell.isDisplayingPlaceholderNow) {
        SDWebImageManager *manager = [SDWebImageManager sharedManager];
        UICollectionViewLayoutAttributes *attr = [self.collectionView layoutAttributesForItemAtIndexPath:indexPath];
        CGRect cellFrame = attr.frame;

        BOOL shouldLoadImageForCurrentCell = YES;
        // 如果正在减速而且当前Cell的frame不在将来滑动停止后的可见区域
        if (self.targetRect &amp;amp;&amp;amp; !CGRectIntersectsRect(self.targetRect.CGRectValue, cellFrame)) {
            // 那么只有Cell的targetURL在内存的缓存中，才去加载它
            SDImageCache *imageCache = [SDImageCache sharedImageCache];
            NSString *key = [manager cacheKeyForURL:[NSURL URLWithString:cell.targetURLString]];
            if (![imageCache imageFromMemoryCacheForKey:key]) {
                shouldLoadImageForCurrentCell = NO;
            }
        }
        if (shouldLoadImageForCurrentCell) {
            [cell loadImage];
        }
    }
}

- (void)loadImageForVisibleCells {
    NSArray *visibleCells = [self.collectionView visibleCells];
    for (UICollectionViewCell *cell in visibleCells) {
        NSIndexPath *indexPath = [self.collectionView indexPathForCell:cell];
        [self loadImageForCell:cell atIndexPath:indexPath];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;做了这些努力后，再去profile一下，发现网速良好情况下滑动时帧率只丢了那么1、2帧，而且滑动起来无明显卡顿！&lt;/p&gt;
&lt;h3 id=&quot;要么不做，要么做绝&quot;&gt;&lt;a href=&quot;#要么不做，要么做绝&quot; class=&quot;headerlink&quot; title=&quot;要么不做，要么做绝&quot;&gt;&lt;/a&gt;要么不做，要么做绝&lt;/h3&gt;&lt;p&gt;哈哈，这个有点狠啊，颇有朱元璋的风格。&lt;/p&gt;
&lt;p&gt;做了这么多后，我们发现，数据预加载完毕后，向CollectionView发送&lt;code&gt;reloadData&lt;/code&gt;消息通知它数据模型变化时，就在这一瞬间，还是会导致CollectionView卡顿那么一下下。&lt;/p&gt;
&lt;p&gt;好吧不能忍，封装一个我们自己的&lt;code&gt;reloadData&lt;/code&gt;方法，在这里简单的hold住reload，根据上文中的&lt;code&gt;targetRect&lt;/code&gt;属性的标记作用，当且仅当在CollectionView减速停止后，再去真正向它发送&lt;code&gt;reloadData&lt;/code&gt;消息。在这里仅提供思路，不做赘述了。&lt;/p&gt;
&lt;p&gt;此外，在开发中，我们把这一系列的方法以&lt;code&gt;NSObject&lt;/code&gt;类的Category形式做一个封装，这样不管谁是CollectionView的Delegate或者DataSource都可以从容应对。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;这里头还是有一定玄机的，篇幅限制只写了关键思路，真正的实践需要一个状态机的思维，不断去感受不断去测试不断去Tuning。当然，&lt;code&gt;UITableView&lt;/code&gt;的优化完全可以使用相同的方式。最后，用户可能感受不到你做了什么，但起码，对得起自己的情怀：）。&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;标记&quot;&gt;&lt;a href=&quot;#标记&quot; class=&quot;headerlink&quot; title=&quot;标记&quot;&gt;&lt;/a&gt;标记&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;[1] Android中的&lt;code&gt;GridView&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[2] Android中的Adapter&lt;/li&gt;
&lt;li&gt;[3] Android中的&lt;code&gt;getView()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tech.glowing.com/cn/practice-in-uiscrollview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UIScrollView 实践经验&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;当App中使用了&lt;code&gt;UICollectionView&lt;/code&gt;以瀑布流的形式来呈现数据时，站在用户的角度，用户在自上至下一页一页浏览这些内容的过程中，当用户感到滑动很流畅自然，每页内容从无到有需要用户等待的时间很短甚至几乎感觉不到，那么&lt;code&gt;UICollectionView&lt;/code&gt;才会带给用户一个很好的体验。本文介绍了为了达到这两个目的所作出的一些客户端的优化。&lt;/p&gt;
    
    </summary>
    
      <category term="移动互联网开发" scheme="http://blog.liushuaiko.be/categories/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.liushuaiko.be/tags/iOS/"/>
    
      <category term="UICollectionView" scheme="http://blog.liushuaiko.be/tags/UICollectionView/"/>
    
  </entry>
  
  <entry>
    <title>Manacher&#39;s algorithm：优雅的求最长回文子串</title>
    <link href="http://blog.liushuaiko.be/blog/2015/04/12/Manachers-algorithm/"/>
    <id>http://blog.liushuaiko.be/blog/2015/04/12/Manachers-algorithm/</id>
    <published>2015-04-12T04:51:06.000Z</published>
    <updated>2016-07-09T05:35:10.000Z</updated>
    
    <content type="html">&lt;p&gt;2015年第一篇文章，力求做到用中文把&lt;a href=&quot;http://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Manacher’s算法&lt;/a&gt;解释的通俗易懂。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;历史-amp-背景&quot;&gt;&lt;a href=&quot;#历史-amp-背景&quot; class=&quot;headerlink&quot; title=&quot;历史&amp;amp;背景&quot;&gt;&lt;/a&gt;历史&amp;amp;背景&lt;/h3&gt;&lt;p&gt;Manacher’s算法是Manacher在1975年提出的一个在线性时间里找出给定字符串中全部回文子串的算法，随着人们的研究，人们发现Manacher’s算法也可以用来求给定字符串的&lt;strong&gt;最长&lt;/strong&gt;回文子串，当然也是线性时间。再后来，有两个小伙提出了基于suffix trees的算法，同样是线性时间求解最长回文子串，慢慢地，人们又找到了一些高效的并行算法求解这类问题。&lt;/p&gt;
&lt;p&gt;本文将阐述Manacher’s算法用于求解给定字符串的最长回文子串，样例代码使用Python。&lt;/p&gt;
&lt;h3 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h3&gt;&lt;p&gt;Manacher’s算法真的很简单，你只要静下心来，花二十分钟来阅读并理解以下文字，绝对可以理解，理解了就一辈子都忘不了，接着你会暗暗叫绝，这算法真太赞了。相信你在看到本文之前也看了很多其他的文章，为了减少读者的理解障碍，使用的变量名称我都会尽量跟其他文章的一样。&lt;/p&gt;
&lt;h4 id=&quot;预处理&quot;&gt;&lt;a href=&quot;#预处理&quot; class=&quot;headerlink&quot; title=&quot;预处理&quot;&gt;&lt;/a&gt;&lt;strong&gt;预处理&lt;/strong&gt;&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;为了将最长子串长度为奇数和偶数这两种情况统一转成奇数情况处理，Manacher’s算法在输入字符串的每个字符之间加了一个特殊字符；&lt;/p&gt;
&lt;p&gt;为了简化处理过程中遍历字符串时对边界条件的判断，在开头加上另一个特殊字符，这些特殊字符要保证不会出现在任何输入字符串里，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/manacher_5.png&quot; alt=&quot;manacher_5&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;OK，下面是理解这个算法的过程中，要&lt;strong&gt;随时装在脑子&lt;/strong&gt;里的一些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回文串：由于我们预处理，我们只考虑回文串为奇数的情况，回文串的特性就是&lt;strong&gt;对称&lt;/strong&gt;，记住&lt;strong&gt;对称&lt;/strong&gt;，在脑子里想想沿着回文串中间的那个字符（下称中心字符）把回文串对折的场景吧，完美的重合。我们把处理后得到的字符串叫s&lt;/li&gt;
&lt;li&gt;考虑s中的任一回文子串，该回文串的中心字符在s中的索引记为center，这个回文串中某个字符在s中的索引是i，那么该字符在该回文串中对称字符的索引&lt;code&gt;j = 2 * center - i&lt;/code&gt;，见下图：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/manacher_4.png&quot; alt=&quot;manacher_4&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;高能预警&quot;&gt;&lt;a href=&quot;#高能预警&quot; class=&quot;headerlink&quot; title=&quot;高能预警&quot;&gt;&lt;/a&gt;&lt;strong&gt;高能预警&lt;/strong&gt;&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;上面的你都理解了，那么我们看算法的精髓部分，静下心。&lt;/p&gt;
&lt;p&gt;首先介绍一下变量，仔细阅读，很重要，下面的叙述是基于这些变量的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/manacher_1.png&quot; alt=&quot;manacher_1&quot;&gt;&lt;/p&gt;
&lt;p&gt;OK，初始假设 current_longest_p_str 的中心字符是 s[0]，也即 center=0，且假设 p[0]=0。&lt;/p&gt;
&lt;p&gt;从 s[1] 开始遍历 s（略过我们为了处理边界在开头加的特殊字符），对 s[i]，分两种情况来看：&lt;/p&gt;
&lt;h5 id=&quot;情况1&quot;&gt;&lt;a href=&quot;#情况1&quot; class=&quot;headerlink&quot; title=&quot;情况1&quot;&gt;&lt;/a&gt;&lt;strong&gt;情况1&lt;/strong&gt;&lt;/h5&gt;&lt;hr&gt;
&lt;p&gt;s[i] 在 current_longest_p_str 内（如果在的话，可以进一步得出，s[i] 一定在其右半部分，因为是按顺序遍历s，i一定大于center）。&lt;/p&gt;
&lt;p&gt;记i关于center的对称点为j（别忘了&lt;code&gt;j = 2 * center - i&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;此时，如果&lt;code&gt;i + p[j] &amp;lt; mx&lt;/code&gt;的话，等价于&lt;code&gt;j - p[j] &amp;gt; mx的对称点&lt;/code&gt;，意味着，以 s[j] 为中心的最长回文串完完整整的在current_longest_p_str内，根据current_longest_p_str的对称性，可得以s[i]为中心的最长回文串也完完整整的在current_longest_p_str内，因此 p[i]=p[j] 成立，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/manacher_3.png&quot; alt=&quot;manacher_3&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;i + p[j] &amp;gt;= mx&lt;/code&gt;的话，意味着，以 s[j] 为中心的最长回文串的一部分在 current_longest_p_str 内。根据 current_longest_p_str 的对称性我们可以知道，以 s[i] 为中心的最长回文子串，至少可以延展到 mx。那 mx 之后的部分呢？由于 mx 之后的字符串我们没办法利用 current_longest_p_str 的对称性了，没办法，只能一个一个去匹配了。转到代码上就是我们可以把 p[i] 置为 mx - i，也即我们已经知道s[i]向右可以扩展到 mx 了（下图橙色框起来部分），再根据逐步向两侧扩展的情况去更新 p[i] 。见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://vars.qiniudn.com/manacher_2.png&quot; alt=&quot;manacher_2&quot;&gt;&lt;/p&gt;
&lt;p&gt;综合以上两种情况，可以得出&lt;code&gt;p[i] = min(p[j], mx - i)&lt;/code&gt;，也即&lt;code&gt;p[i] = min(p[2 * center - i], mx - i)&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;情况2&quot;&gt;&lt;a href=&quot;#情况2&quot; class=&quot;headerlink&quot; title=&quot;情况2&quot;&gt;&lt;/a&gt;&lt;strong&gt;情况2&lt;/strong&gt;&lt;/h5&gt;&lt;hr&gt;
&lt;p&gt;s[i]不在 current_longest_p_str 中，没办法利用 current_longest_p_str 的对称性，只能先将 p[i] 置为0，再向两侧扩展一个一个匹配来更新 p[i] 了。&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pre_process&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, s)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;.join((&lt;span class=&quot;string&quot;&gt;&quot;$#&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;.join(s), &lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# @return a string&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;longestPalindrome&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, s)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        s_new = self.pre_process(s)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        p = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        center = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        mx = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, len(s_new)):&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 情况2，s[i]不在current_longest_p_str中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &amp;gt; mx:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                p.append(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 情况1，s[i]在current_longest_p_str中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                p.append(min(mx - i, p[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * center - i]))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 没办法，只能一个一个去匹配了&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 注意，对于以s[i]为中心的最长回文子串完完整整包括在current_longest_p_str的情况，while循环不会执行，想想为什么&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i - p[i] - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; (i + p[i]  + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;lt; len(s_new) &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; s_new[i - p[i] - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] == s_new[i + p[i] + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                p[i] += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 更新current_longest_p_str相关信息&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p[i] &amp;gt; mx - center:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                center = i&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                mx = i + p[i]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s_new[center - p[center]: center + p[center] + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].replace(&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;希望能给你带来一点帮助，如有理解错误，恳请指正。&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.felix021.com/blog/read.php?2040&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Manacher’s ALGORITHM: O(n)时间求字符串的最长回文子串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Manacher’s Algorithm – Linear Time Longest Palindromic Substring – Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Longest Palindromic Substring Part II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2015年第一篇文章，力求做到用中文把&lt;a href=&quot;http://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm&quot;&gt;Manacher’s算法&lt;/a&gt;解释的通俗易懂。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://blog.liushuaiko.be/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Manacher" scheme="http://blog.liushuaiko.be/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>我的2014</title>
    <link href="http://blog.liushuaiko.be/blog/2014/12/30/my-2014/"/>
    <id>http://blog.liushuaiko.be/blog/2014/12/30/my-2014/</id>
    <published>2014-12-30T13:39:44.000Z</published>
    <updated>2016-07-09T05:34:20.000Z</updated>
    
    <content type="html">&lt;p&gt;不知是自己接触的技术越来越牛逼了还是接触的东西越来越弱智了，这一年真的很少提笔去写一些技术上的文章。这种表达个人情感的文章写多了又会觉得自己很矫情，那么今年的年终总结我会力求不带任何感情色彩。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;改变&quot;&gt;&lt;a href=&quot;#改变&quot; class=&quot;headerlink&quot; title=&quot;改变&quot;&gt;&lt;/a&gt;改变&lt;/h4&gt;&lt;p&gt;哈尔滨到杭州，旧知己到新搭档，Android到iOS，无拘无束到谨小慎微，只求自己的棱角不被磨平，无论何时像鹏总那样保持着对技术的热爱与激情。&lt;/p&gt;
&lt;p&gt;做得饭越来越好吃。&lt;/p&gt;
&lt;h4 id=&quot;读书&quot;&gt;&lt;a href=&quot;#读书&quot; class=&quot;headerlink&quot; title=&quot;读书&quot;&gt;&lt;/a&gt;读书&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;《白夜行》&lt;/li&gt;
&lt;li&gt;《嫌疑犯X的献身》&lt;/li&gt;
&lt;li&gt;《Objective-C高级编程》&lt;/li&gt;
&lt;li&gt;《iOS Programming : The Big Nerd Ranch Guide》&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;影视&quot;&gt;&lt;a href=&quot;#影视&quot; class=&quot;headerlink&quot; title=&quot;影视&quot;&gt;&lt;/a&gt;影视&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;电影：37部，《星际穿越》等&lt;/li&gt;
&lt;li&gt;美剧：4部，《绝命毒师》、《权力的游戏》、《越狱》、《行尸走肉》&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;旅行&quot;&gt;&lt;a href=&quot;#旅行&quot; class=&quot;headerlink&quot; title=&quot;旅行&quot;&gt;&lt;/a&gt;旅行&lt;/h4&gt;&lt;p&gt;青岛4日游。&lt;/p&gt;
&lt;h4 id=&quot;第一&quot;&gt;&lt;a href=&quot;#第一&quot; class=&quot;headerlink&quot; title=&quot;第一&quot;&gt;&lt;/a&gt;第一&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;第一次坐飞机&lt;/li&gt;
&lt;li&gt;第一次坐高铁&lt;/li&gt;
&lt;li&gt;第一次海淘&lt;/li&gt;
&lt;li&gt;第一份工资&lt;/li&gt;
&lt;li&gt;第一次用工资给父母买东西&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;2个月全职+￥6300考下了驾照&lt;/li&gt;
&lt;li&gt;往instagram上传了38张照片&lt;/li&gt;
&lt;li&gt;写了13篇技术博客&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;入手的东西&quot;&gt;&lt;a href=&quot;#入手的东西&quot; class=&quot;headerlink&quot; title=&quot;入手的东西&quot;&gt;&lt;/a&gt;入手的东西&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Kindle Paperwhite 2&lt;/li&gt;
&lt;li&gt;Razer DeathAdder 鼠标&lt;/li&gt;
&lt;li&gt;Logitech M545 无线鼠标&lt;/li&gt;
&lt;li&gt;RainDesign mStand&lt;/li&gt;
&lt;li&gt;Casio AQ-S810W-1AV Solar Watch&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;技术提高不多。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不知是自己接触的技术越来越牛逼了还是接触的东西越来越弱智了，这一年真的很少提笔去写一些技术上的文章。这种表达个人情感的文章写多了又会觉得自己很矫情，那么今年的年终总结我会力求不带任何感情色彩。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.liushuaiko.be/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Python入门分享</title>
    <link href="http://blog.liushuaiko.be/blog/2014/12/29/Python-Introduction/"/>
    <id>http://blog.liushuaiko.be/blog/2014/12/29/Python-Introduction/</id>
    <published>2014-12-29T14:33:02.000Z</published>
    <updated>2016-07-09T05:34:24.000Z</updated>
    
    <content type="html">&lt;p&gt;给组内小伙伴们分享Python知识做的slides，本来分享共有三场，但是由于种种原因第三场取消了，也就没去准备.其实第三次分享本来也是要讲那些“Google + 官方文档”就可以搞定的东西。把前两次分享的slides给大家分享出来。&lt;/p&gt;
&lt;p&gt;在slideshare上，自备梯子。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/43048982&quot; width=&quot;425&quot; height=&quot;355&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/ssuser146893/python-1-43048982&quot; title=&quot;Introduction to Python-1&quot; target=&quot;_blank&quot;&gt;Introduction to Python(1) - History and Basics&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;//www.slideshare.net/ssuser146893&quot; target=&quot;_blank&quot;&gt;Shuai Liu&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;
&lt;p&gt;&lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/43048983&quot; width=&quot;425&quot; height=&quot;355&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&quot;margin-bottom:5px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/ssuser146893/python-2-43048983&quot; title=&quot;Introduction to Python-2&quot; target=&quot;_blank&quot;&gt;Introduction to Python(2) - Advanced and Be Pythonic&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a href=&quot;//www.slideshare.net/ssuser146893&quot; target=&quot;_blank&quot;&gt;Shuai Liu&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;给组内小伙伴们分享Python知识做的slides，本来分享共有三场，但是由于种种原因第三场取消了，也就没去准备.其实第三次分享本来也是要讲那些“Google + 官方文档”就可以搞定的东西。把前两次分享的slides给大家分享出来。&lt;/p&gt;
&lt;p&gt;在slideshare上，自备梯子。&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计语言" scheme="http://blog.liushuaiko.be/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://blog.liushuaiko.be/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>读书的日子</title>
    <link href="http://blog.liushuaiko.be/blog/2014/11/07/when-I-was-at-school/"/>
    <id>http://blog.liushuaiko.be/blog/2014/11/07/when-I-was-at-school/</id>
    <published>2014-11-07T13:45:14.000Z</published>
    <updated>2016-07-09T05:42:58.000Z</updated>
    
    <content type="html">&lt;p&gt;说来也巧，晚上跟意林匆匆吃了个饭，晚上回来听到的第一首歌就是曾经听意林唱过的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;郝云的&lt;a href=&quot;http://www.xiami.com/song/1772141275&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《活着》&lt;/a&gt;。那是大学里最后一次班饭，吃完了大家似乎还不尽兴，由彪彪撺掇着去了学校后面的KTV，大家外表上没有表现出任何要散伙的伤感，班上的几个比较腼腆的同学还是不怎么说话，对唱歌不感冒的几个同学凑成一桌打起了牌。记不清是谁点了这首歌，但开始是梁栋拿着话筒准备唱的，意林是属于比较活跃的类型，听到前奏后赶忙去抢了另一只话筒，就这样我全程听完了他们唱的这首歌。&lt;/p&gt;
&lt;p&gt;听的时候就一个感觉，我靠将来的生活不会就是歌里唱的那样吧。&lt;/p&gt;
&lt;p&gt;梁栋，大一军训时站我身边的人。那时大家都很腼腆，努力给人留个好印象。意林跟梁栋都是我隔壁宿舍的，他们给我的感觉就是从来不为学分绩发愁，每天都过得很快乐，因此听歌的时候我觉得这首歌真是配极了他们。&lt;/p&gt;
&lt;p&gt;今天跟意林说到，来杭小三分之一年了。很多时候真是怀念极了哈尔滨那个冰天雪地的城市，怀念极了在大学的日子。当时我决定放弃保研，家人，各种同学等我深爱的人都说别了吧，offer年年有，保研弃了将来再想读研可就难了，甚至是到现在，就在今晚，吃完饭时意林还说，“你这能保研的不保研”，我也是醉了。那么现在你问我呢，谈不上后悔，就两点让我耿耿于怀，其一，现在生活中，没有一个想骂“傻B”就可以不用思考直接脱口而出的人，更多情况甚至思考了也不能脱口而出，其二，不会随便喊两句，就会有人跟我一起去游泳，去滑冰，去…..等等。&lt;/p&gt;
&lt;p&gt;那么，现在还在国内上学的同学们，我从一个过来人的角度给你们个建议。&lt;/p&gt;
&lt;p&gt;无论你在哪个学校，在围墙内还是围墙外，无论什么原因还在读书，请一定要&lt;strong&gt;珍惜当下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;大四的时候，郭哥就不停给我灌输，大四是你人生中最闲的日子。到现在我觉得郭哥说的太有道理了。读书的日子，是人生中最快乐、最自由的日子。在大四我考下了驾照，学会了游泳，做完了毕设，差一点得了校优，能在刮着风的下午陪Cliff去打篮球，我很庆幸能有这些经历和回忆。正因为这些都变成了回忆，我就更加羡慕现在还在读书的人，希望你们珍惜当下，享受读书的生活。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;慌慌张张 匆匆忙忙&lt;br&gt;为何生活总是这样&lt;br&gt;难道说我的理想&lt;br&gt;就是这样度过一生的时光&lt;br&gt;不卑不亢 不慌不忙&lt;br&gt;也许生活应该这样&lt;br&gt;难道说六十岁以后&lt;br&gt;再去寻找我想要的自由&lt;br&gt;一年一年飞逝而去   &lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;说来也巧，晚上跟意林匆匆吃了个饭，晚上回来听到的第一首歌就是曾经听意林唱过的。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.liushuaiko.be/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之内存管理（2）——After ARC</title>
    <link href="http://blog.liushuaiko.be/blog/2014/07/31/ios-memory-management-arc/"/>
    <id>http://blog.liushuaiko.be/blog/2014/07/31/ios-memory-management-arc/</id>
    <published>2014-07-31T03:03:49.000Z</published>
    <updated>2016-07-09T05:42:57.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一定要记住，&lt;a href=&quot;http://blog.vars.me/blog/2014/07/30/ioskai-fa-zhi-nei-cun-guan-li-1-before-arc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上文&lt;/a&gt;所提到的“引用计数式内存管理”的本质部分在ARC中并没有相应的改变。ARC只是在RC的前面加了一个A，即自动帮我们处理“引用计数”的相关部分。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;所有权修饰符&quot;&gt;&lt;a href=&quot;#所有权修饰符&quot; class=&quot;headerlink&quot; title=&quot;所有权修饰符&quot;&gt;&lt;/a&gt;所有权修饰符&lt;/h3&gt;&lt;p&gt;当ARC有效时，id类型和OC的对象类型在声明变量时必须加上所有权修饰符，共有四种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__strong
__weak
__unsafe_unretained
__autoreleasing
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;strong&quot;&gt;&lt;a href=&quot;#strong&quot; class=&quot;headerlink&quot; title=&quot;__strong&quot;&gt;&lt;/a&gt;&lt;code&gt;__strong&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;这是id类型和对象类型&lt;strong&gt;默认&lt;/strong&gt;的所有权修饰符。也就是说，&lt;strong&gt;ARC有效时&lt;/strong&gt;，下面的代码，实际上是被附加了所有权修饰符。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;id obj = [[NSObject alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 上面一行代码与下面这行相同&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;id __strong obj = [[NSObject alloc] init];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;附有&lt;code&gt;__strong&lt;/code&gt;修饰符的变量obj在超出其变量作用域时，即在该变量应该被废弃时，会释放其被赋予的对象。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id __strong obj = [[NSObject alloc] init]; // 强引用，自己持有该对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 到此为止，超出了obj的作用域，强引用失效，obj自动释放持有的对象，而对象的所有者不存在，因此废弃该对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 可见，默认的__strong与Java类似&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码等价与在&lt;strong&gt;ARC无效&lt;/strong&gt;时的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id obj = [[NSObject alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [obj release];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到，ARC我们不用手动调用retain和release，非常方便，如果你之前写过Java，就更觉得这才是本来应该有的方式嘛！在ARC有效时，取得非自己生成并持有的对象，在超出变量作用域时，也会自动释放变量所持有的对象（这仅仅会导致对象的引用计数减1，但是这不等于一定会废弃该对象，因为对象可能还被其他变量所引用）。&lt;/p&gt;
&lt;p&gt;但是，Java的内存管理跟OC还是有很大不同的，具体的可以看看知乎上的&lt;a href=&quot;http://t.cn/RPIXYa2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇回答&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;weak&quot;&gt;&lt;a href=&quot;#weak&quot; class=&quot;headerlink&quot; title=&quot;__weak&quot;&gt;&lt;/a&gt;&lt;code&gt;__weak&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;看起来通过&lt;code&gt;__strong&lt;/code&gt;可以完美的解决内存管理和回收的问题，但是这里面有一个重大的问题——&lt;strong&gt;循环引用&lt;/strong&gt;！&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 定义Test类&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@interface Test: NSObject&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id __strong obj_;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (void)setObject:(id __strong)obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@end&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@implementation Test&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (id)init&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    self = [super init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return self;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (void)setObject:(id __strong)obj&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    obj_ = obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@end&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 以下为循环引用&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 对象A&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // test0持有对象A的强引用&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id test0 = [[Test alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 对象B&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // test1持有对象B的强引用&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id test1 = [[Test alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 对象A的obj_成员持有对象B的强引用&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 此时，持有对象B强引用的变量为test1和对象A的obj_变量&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [test0 setObject:test1];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 同上分析&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [test1 setObject:test0];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 到这为止超出了test0和test1变量的作用域，他们的强引用失效。分别释放各自持有的Test对象&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 但是，对象A被对象B的obj_持有（强引用），对象B被对象A的obj_持有（强引用）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 发生了内存泄露！&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不仅上面的情况，在对象自己持有其自身时，也会发生循环引用导致内存泄露。&lt;/p&gt;
&lt;p&gt;那么怎么避免循环引用呢，使用&lt;code&gt;__weak&lt;/code&gt;就可以做到了！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__weak&lt;/code&gt;修饰符与&lt;code&gt;__strong&lt;/code&gt;相反，提供弱引用。弱引用不持有对象的实例，不会导致对象的引用计数加1。&lt;code&gt;__weak&lt;/code&gt;修饰符还有一个优点就是如果一个变量持有对象的弱引用，当该对象被废弃时，变量将自动失效并且被赋值成nil，与Java的WeakReference很像，因此，&lt;code&gt;__weak&lt;/code&gt;修饰符的变量在使用时应当判断是否为nil。&lt;/p&gt;
&lt;p&gt;这样，使用&lt;code&gt;__weak&lt;/code&gt;修饰符就可以不会导致对象的引用计数加1，正确的使用可以避免出现引用环，从而避免循环引用。&lt;/p&gt;
&lt;h4 id=&quot;unsafe-unretained&quot;&gt;&lt;a href=&quot;#unsafe-unretained&quot; class=&quot;headerlink&quot; title=&quot;__unsafe_unretained&quot;&gt;&lt;/a&gt;&lt;code&gt;__unsafe_unretained&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;遗憾的是，&lt;code&gt;__weak&lt;/code&gt;修饰符只能用于iOS5以上及OS X Lion以上版本的程序，以下的APP不得不使用&lt;code&gt;__unsafe_unretained&lt;/code&gt;。正如其名，该修饰符是不安全的修饰符。尽管使用ARC式内存管理是编译器的工作，但附有该修饰符的变量不属于编译器的内存管理对象，这点要注意。&lt;/p&gt;
&lt;p&gt;附有&lt;code&gt;__unsafe_unretained&lt;/code&gt;修饰符的变量同附有&lt;code&gt;__weak&lt;/code&gt;修饰符的变量一样，也是不持有对象的，但是唯一的区别是，当对象被废弃时，变量不会被置成nil，可能会造成“野指针”！&lt;/p&gt;
&lt;h4 id=&quot;autoreleasing&quot;&gt;&lt;a href=&quot;#autoreleasing&quot; class=&quot;headerlink&quot; title=&quot;__autoreleasing&quot;&gt;&lt;/a&gt;&lt;code&gt;__autoreleasing&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;ARC有效时，显式地附加&lt;code&gt;__autoreleasing&lt;/code&gt;修饰符比较罕见。这块基本上编译器已经帮你弄好了，你不需要怎么关心，对于新手来说，把上面的理解应该就够了。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;&lt;a href=&quot;#后记&quot; class=&quot;headerlink&quot; title=&quot;后记&quot;&gt;&lt;/a&gt;后记&lt;/h3&gt;&lt;p&gt;有一个很好的比喻来帮助理解这些修饰符，对象就是气球，&lt;code&gt;__strong&lt;/code&gt;指针像线，&lt;code&gt;__weak&lt;/code&gt;指针像看着气球的眼睛（气球跑了我是知道的，我就不去看气球了），&lt;code&gt;__unsafe_retained&lt;/code&gt;指针像一道射向气球的激光（即使气球跑了也不知道，激光依然照向那个位置），&lt;code&gt;__autoreleasing&lt;/code&gt;像挡着气球的屋顶（可以挡住多个气球）。&lt;/p&gt;
&lt;p&gt;如果我有什么地方理解有错误，恳请指正，因为我是绝对的新手。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一定要记住，&lt;a href=&quot;http://blog.vars.me/blog/2014/07/30/ioskai-fa-zhi-nei-cun-guan-li-1-before-arc/&quot;&gt;上文&lt;/a&gt;所提到的“引用计数式内存管理”的本质部分在ARC中并没有相应的改变。ARC只是在RC的前面加了一个A，即自动帮我们处理“引用计数”的相关部分。&lt;/p&gt;
    
    </summary>
    
      <category term="移动互联网开发" scheme="http://blog.liushuaiko.be/categories/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.liushuaiko.be/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之内存管理（1）——Before ARC</title>
    <link href="http://blog.liushuaiko.be/blog/2014/07/30/ios-memory-management-mrc/"/>
    <id>http://blog.liushuaiko.be/blog/2014/07/30/ios-memory-management-mrc/</id>
    <published>2014-07-30T09:23:10.000Z</published>
    <updated>2016-07-09T05:42:56.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Automatic-Reference-Counting&quot;&gt;&lt;a href=&quot;#Automatic-Reference-Counting&quot; class=&quot;headerlink&quot; title=&quot;Automatic Reference Counting&quot;&gt;&lt;/a&gt;Automatic Reference Counting&lt;/h3&gt;&lt;p&gt;提到Objective-C中的内存管理，就不得不提到ARC（自动引用计数）。使用了ARC和不使用ARC，OC内存管理方式没有变，都是基于引用计数，但是程序员在编写代码上大有不同。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;首先要明确的&quot;&gt;&lt;a href=&quot;#首先要明确的&quot; class=&quot;headerlink&quot; title=&quot;首先要明确的&quot;&gt;&lt;/a&gt;首先要明确的&lt;/h3&gt;&lt;p&gt;内存管理的目的，简而言之，就是确保对象在分配了内存并初始化后，程序中要用到该对象时候，对象还在，程序不再使用该对象时，该对象占用的内存能及时释放，不会造成内存泄露。&lt;/p&gt;
&lt;p&gt;在引用计数式内存管理中，还要明确以下几点（说原则不是原则，读了之后你就明白了）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 自己生成的对象，自己所持有
* 非自己生成的对象，自己也可以持有
* 自己持有的对象，不再需要时释放
* 非自己持有的对象，不能释放
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;持有，比较难理解，意思是有一个强引用指向了对象，&lt;strong&gt;持有了对象 &amp;lt;=&amp;gt; 导致对象的引用计数加1&lt;/strong&gt;。把对象比喻成氢气球，持有就是用一根线拴住了气球，你拿着气球线。&lt;/p&gt;
&lt;h3 id=&quot;Before-ARC&quot;&gt;&lt;a href=&quot;#Before-ARC&quot; class=&quot;headerlink&quot; title=&quot;Before ARC&quot;&gt;&lt;/a&gt;Before ARC&lt;/h3&gt;&lt;p&gt;在ARC之前，程序员需要手动管理内存，对对象的持有和释放主要是通过retain和release方法来完成的。&lt;/p&gt;
&lt;p&gt;虽然新版本的SDK默认使用了ARC，但是正如郭总说的，真是不能同意更多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;选择SDK要注意的一点就是，在iOS 4.0以后，引入了Auto Reference Counting（ARC）这一技术，个人感觉使用ARC虽然方便了内存管理，但是对于新手来说缺少了手动管理内存的历练，这里欠下的债，将来一定要还的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;自己生成的对象，自己所持有&quot;&gt;&lt;a href=&quot;#自己生成的对象，自己所持有&quot; class=&quot;headerlink&quot; title=&quot;自己生成的对象，自己所持有&quot;&gt;&lt;/a&gt;自己生成的对象，自己所持有&lt;/h4&gt;&lt;p&gt;下面的代码，意味着创建了一个NSObject的对象，并让id类型的变量obj持有了该对象。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;id obj = [[NSObject alloc] init];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此外，如果你的方法使用以下名称开头（驼峰式开头，例如名为allocate的方法就不会有相同的效果），意为着调用这些方法达到的效果是一致的，都是生成了一个对象，并返回一个指向该对象并持有该对象的指针。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alloc
new
copy
mutableCopy
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;非自己生成的对象，自己也可以持有&quot;&gt;&lt;a href=&quot;#非自己生成的对象，自己也可以持有&quot; class=&quot;headerlink&quot; title=&quot;非自己生成的对象，自己也可以持有&quot;&gt;&lt;/a&gt;非自己生成的对象，自己也可以持有&lt;/h4&gt;&lt;p&gt;不是自己把对象造出来的，但是也可以持有这个对象。&lt;/p&gt;
&lt;p&gt;如下面的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;id obj = [NSMutableArray array];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;到此为止，上面的代码并没有创建一个NSMutableArray，仅仅是取得了对象的存在（这是通过autorelease实现的），也即仅仅获得了对象的地址，obj没有持有对象，也即对象的引用计数并未因这行代码而加1。&lt;/p&gt;
&lt;p&gt;但是，当你给obj发送retain的消息后，obj就持有了对象，对象的引用计数加1了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[obj retain];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;自己持有的对象，不再需要时释放-非自己持有的对象，不能释放&quot;&gt;&lt;a href=&quot;#自己持有的对象，不再需要时释放-非自己持有的对象，不能释放&quot; class=&quot;headerlink&quot; title=&quot;自己持有的对象，不再需要时释放 | 非自己持有的对象，不能释放&quot;&gt;&lt;/a&gt;自己持有的对象，不再需要时释放 | 非自己持有的对象，不能释放&lt;/h4&gt;&lt;p&gt;自己持有的对象，一旦不再需要，持有者有义务释放对象。释放对象使用的是release方法。记住一定得是持有了对象才能释放，你根本就没牵住气球怎么释放啊。&lt;/p&gt;
&lt;p&gt;看下面的例子。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;id obj = [[NSObject alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[obj release];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们首先生成了一个对象，并让obj持有了对象，接着我们调用release方法释放了对象。在release方法内部会判断对象的引用计数，如果为0了就调用对象的dealloc方法废弃对象。&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;调用alloc或者retain方法后，引用计数值加1&lt;/li&gt;
&lt;li&gt;调用release后，引用计数值减1&lt;/li&gt;
&lt;li&gt;引用计数值为0时，调用dealloc方法废弃对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记住，这些都是在没有ARC，程序员进行手动内存管理时的一些东西。&lt;/p&gt;
&lt;h3 id=&quot;After-ARC&quot;&gt;&lt;a href=&quot;#After-ARC&quot; class=&quot;headerlink&quot; title=&quot;After ARC&quot;&gt;&lt;/a&gt;After ARC&lt;/h3&gt;&lt;p&gt;自从有了ARC，一切都不一样了。具体请看&lt;a href=&quot;http://blog.vars.me/blog/2014/07/31/ioskai-fa-zhi-nei-cun-guan-li-2-after-arc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;还看了其他的东西，如autorelease和autoreleasepool等，以及引用计数具体的实现（直接将引用计数保存在对象里和使用散列表等），说太多不容易被接受，再加上自己的理解也不是很透彻，就不叙述了。&lt;/p&gt;
&lt;p&gt;此外推荐一些比较有用的OC和iOS的网站：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.raywenderlich.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;raywenderlich&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.objc.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc&lt;/a&gt; | &lt;a href=&quot;http://objccn.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc中文翻译&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文参考文献：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/24720270/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Objective-C高级编程》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后送一句话，与君共勉。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要因为走得太远，就忘了自己为什么出发。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Automatic-Reference-Counting&quot;&gt;&lt;a href=&quot;#Automatic-Reference-Counting&quot; class=&quot;headerlink&quot; title=&quot;Automatic Reference Counting&quot;&gt;&lt;/a&gt;Automatic Reference Counting&lt;/h3&gt;&lt;p&gt;提到Objective-C中的内存管理，就不得不提到ARC（自动引用计数）。使用了ARC和不使用ARC，OC内存管理方式没有变，都是基于引用计数，但是程序员在编写代码上大有不同。&lt;/p&gt;
    
    </summary>
    
      <category term="移动互联网开发" scheme="http://blog.liushuaiko.be/categories/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://blog.liushuaiko.be/tags/iOS/"/>
    
  </entry>
  
</feed>
